{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"home","text":"<p>{% include-markdown \"../README.md\" %}</p>"},{"location":"api/","title":"API","text":""},{"location":"api/#binapy","title":"<code>binapy</code>","text":"<p>Top-level package for BinaPy.</p>"},{"location":"api/#binapy.BinaPy","title":"<code>BinaPy</code>","text":"<p>             Bases: <code>bytes</code></p> <p>A helper class for binary data manipulation.</p> <p>This subclass of <code>bytes</code> exposes various binary data manipulation methods. Since this is a <code>bytes</code> subclass, you can use instances of <code>BinaPy</code> anywhere you can use <code>bytes</code>. BinaPy allows (re)encoding of data using <code>encode_to(&lt;format&gt;)</code>, decoding using <code>decode_from(&lt;format&gt;)</code>, parsing using <code>parse_from(&lt;format&gt;)</code>, and serialisation using <code>serialize_to(&lt;format&gt;)</code>.</p> <p>Actual transformations into formats such as Base64, JSON, etc. are implemented using Extensions. Those extensions are registered using the decorators <code>binapy_encoder</code>, <code>binapy_decoder</code>, <code>binapy_checker</code>, <code>binapy_serializer</code>, and <code>binapy_parser</code>.</p> Source code in <code>binapy/binapy.py</code> <pre><code>class BinaPy(bytes):\n    \"\"\"A helper class for binary data manipulation.\n\n    This subclass of `bytes` exposes various binary data manipulation methods. Since this is\n    a `bytes` subclass, you can use instances of `BinaPy` anywhere you can use `bytes`. BinaPy\n    allows (re)encoding of data using `encode_to(&lt;format&gt;)`, decoding using\n    `decode_from(&lt;format&gt;)`, parsing using `parse_from(&lt;format&gt;)`, and serialisation using\n    `serialize_to(&lt;format&gt;)`.\n\n    Actual transformations into formats such as Base64, JSON, etc. are implemented using\n    Extensions. Those extensions are registered using the decorators `binapy_encoder`,\n    `binapy_decoder`, `binapy_checker`, `binapy_serializer`, and `binapy_parser`.\n\n    \"\"\"\n\n    def __new__(\n        cls,\n        value: bytes | str | int | SupportsBytes = b\"\",\n        encoding: str = \"utf-8\",\n        errors: str = \"strict\",\n    ) -&gt; BinaPy:\n        \"\"\"Override base method to accept a string with a default encoding of \"utf-8\".\n\n        See Also:\n            [`bytes` constructor](https://docs.python.org/3/library/stdtypes.html#bytes) and\n            [`str.encode()`](https://docs.python.org/3/library/stdtypes.html#str.encode)\n\n        Args:\n            value: a `bytes` or a `str`\n            encoding: if value is a `str`, specify the encoding to use to encode this str to bytes\n            errors: 'strict', 'ignore', 'replace', 'xmlcharrefreplace', or 'backslashreplace'\n\n        \"\"\"\n        if isinstance(value, str):\n            obj = bytes.__new__(cls, value, encoding=encoding, errors=errors)\n        else:\n            obj = bytes.__new__(cls, value)\n        return obj\n\n    @classmethod\n    def from_int(\n        cls,\n        i: int,\n        *,\n        length: int | None = None,\n        byteorder: Literal[\"little\", \"big\"] = \"big\",\n        signed: bool = False,\n    ) -&gt; BinaPy:\n        \"\"\"Convert an `int` to a `BinaPy`.\n\n        This is a wrapper around [int.to_bytes()](https://docs.python.org/3/library/stdtypes.html#int.to_bytes) and\n        takes the same parameters.\n\n        Args:\n            i: the integer to convert to BinaPy\n            length: the length of the integer, in bytes.\n              If omitted,default to the minimal length that fits the given integer.\n            byteorder: \"little\" or \"big\" (defaults to \"big\")\n            signed: determines whether two's complement is used to represent the integer.\n\n        Returns:\n            a BinaPy with the binary representation of the given integer\n\n        \"\"\"\n        if length is None:\n            length = (i.bit_length() + 7) // 8\n\n        data = i.to_bytes(length, byteorder, signed=signed)\n        return cls(data)\n\n    def ascii(self) -&gt; str:\n        \"\"\"Decode this BinaPy to a str.\n\n        This makes sure that only ascii characters are part of the result.\n\n        Returns:\n            a str with only ASCII chars\n\n        \"\"\"\n        return self.decode(\"ascii\")\n\n    def re_match(self, pattern: str, encoding: str = \"ascii\") -&gt; str:\n        \"\"\"Decode this binary value to a string, then match it to a regex.\n\n        Decoding is done using the encoding defined in `encoding` (default to \"ascii\").\n        The decoded value is then matched with the regular expression `pattern`.\n\n        If the match is successful, return the decoded string. Raise a `ValueError` otherwise.\n\n        Args:\n            pattern: the regular expression pattern to match\n            encoding: the encoding to use to decode the binary value to a string\n\n        Returns:\n            the decoded, matching `str`\n\n        Raises:\n            ValueError: if the decoded str does not match `pattern`\n\n        \"\"\"\n        res = self.decode(encoding)\n        if re.match(pattern, res):\n            return res\n        msg = f\"This value does not match pattern {pattern}\"\n        raise ValueError(msg)\n\n    def text(self, encoding: str = \"ascii\") -&gt; str:\n        r\"\"\"Decode this BinaPy to a str, and check that the result is printable.\n\n        Printable characters are characters from the range `[a-zA-Z0-9!\"#$%&amp;\\'()*+,-./:;&lt;=&gt;?@[\\\\]^_`{|}~ ]`.\n\n        Args:\n            encoding: the encoding to use to decode the binary data\n\n        Returns:\n            the decoded text\n\n        \"\"\"\n        return self.re_match(r'^[a-zA-Z0-9!\"#$%&amp;\\'()*+,-./:;&lt;=&gt;?@[\\\\]^_`{|}~ ]*$', encoding)\n\n    def urlsafe(self) -&gt; str:\n        r\"\"\"Convert this BinaPy to a str, and check that it contains only url-safe characters.\n\n        Url-safe characters are `[A-Za-z0-9_.\\\\-~]`.\n\n        Returns:\n                 a str with only URL-safe chars\n\n        \"\"\"\n        return self.re_match(r\"^[A-Za-z0-9_.\\-~]$\")\n\n    def alphanumeric(self) -&gt; str:\n        \"\"\"Check that this BinaPy contains only alphanumeric characters.\n\n        Returns:\n                 a str with only alphanumeric chars\n\n        \"\"\"\n        return self.re_match(r\"^[a-zA-Z]$\")\n\n    def to_int(self, *, byteorder: Literal[\"little\", \"big\"] = \"big\", signed: bool = False) -&gt; int:\n        \"\"\"Convert this BinaPy to an `int`.\n\n        This is a wrapper around\n        [int.from_bytes()](https://docs.python.org/3/library/stdtypes.html#int.from_bytes) and takes\n        the same parameters.\n\n        Args:\n            byteorder: \"little\" or \"big\" (defaults to \"big\")\n            signed: determines whether two's complement is used to represent the integer. Default to False.\n\n        Returns:\n            an integer based on this BinaPy binary value\n\n        \"\"\"\n        return int.from_bytes(self, byteorder, signed=signed)\n\n    @classmethod\n    def from_binary_string(cls, s: str, *, byteorder: Literal[\"little\", \"big\"] = \"big\", signed: bool = False) -&gt; BinaPy:\n        \"\"\"Initialize a BinaPy based on a binary string (containing only 0 and 1).\n\n        The string may contain spaces or tabs characters which will be ignored.\n\n        Args:\n            s: a binary string\n            byteorder: byte order to use\n            signed: True if 2 complement is used to represent negative values\n\n        Returns:\n            a BinaPy\n\n        \"\"\"\n        s = s.replace(\" \", \"\").replace(\"\\t\", \"\")\n        return cls(int(s, 2).to_bytes((len(s) + 7) // 8, byteorder=byteorder, signed=signed))\n\n    def to_binary_string(\n        self,\n        *,\n        byteorder: Literal[\"little\", \"big\"] = \"big\",\n        signed: bool = False,\n        pad: bool = True,\n    ) -&gt; str:\n        \"\"\"Return a string containing this BinaPy value in binary representation.\n\n        Args:\n            byteorder: byte order to use\n            signed: `True` if 2 complement is used to represent negative values\n            pad: if `True`, left pad the result with 0 to make length a multiple of 8\n\n        Returns:\n            a string with containing only 0 and 1\n\n        \"\"\"\n        binary = format(self.to_int(byteorder=byteorder, signed=signed), \"b\")\n        if pad and len(binary) % 8:\n            d = len(binary) // 8\n            return binary.rjust(8 * d + 8, \"0\")\n        return binary\n\n    @classmethod\n    def random(cls, length: int) -&gt; BinaPy:\n        \"\"\"Return a BinaPy containing `length` random bytes.\n\n        Args:\n            length: number of bytes to generate\n\n        Returns:\n            a BinaPy with randomly generated data\n\n        \"\"\"\n        return cls(secrets.token_bytes(length))\n\n    @classmethod\n    def random_bits(cls, length: int) -&gt; BinaPy:\n        \"\"\"Return a BinaPy containing `length` random bits. Same as random(length//8).\n\n        Length must be a multiple of 8.\n\n        Args:\n            length: number of bits to randomly generate\n\n        Returns:\n            a BinaPy with randomly generated data\n\n        \"\"\"\n        return cls(secrets.token_bytes(length // 8))\n\n    @overload\n    def __getitem__(self, index: SupportsIndex) -&gt; int:\n        ...  # pragma: no cover\n\n    @overload\n    def __getitem__(self, slice: slice) -&gt; BinaPy:  # noqa: A002\n        ...  # pragma: no cover\n\n    def __getitem__(self, slice: slice | SupportsIndex) -&gt; int | BinaPy:  # noqa: A002\n        \"\"\"Override the base method so that slicing returns a BinaPy instead of just bytes.\n\n        Args:\n            slice: a slice or index\n\n        Returns:\n            A BinaPy\n\n        \"\"\"\n        if isinstance(slice, int):\n            return super().__getitem__(slice)\n        return self.__class__(super().__getitem__(slice))\n\n    def char_at(self, index: int) -&gt; str:\n        \"\"\"Return the character at the given index.\n\n        Slicing a standard bytes returns an int. Sometimes what you really want is a single char string.\n\n        Args:\n            index: the index of the desired character\n\n        Returns:\n            the single character at the given index\n\n        \"\"\"\n        return chr(self[index])\n\n    def __add__(\n        self,\n        other: Any,\n    ) -&gt; BinaPy:\n        \"\"\"Override base method so that addition returns a BinaPy instead of bytes.\n\n        Args:\n            other: bytes or BinaPy to add\n\n        Returns:\n            a BinaPy\n\n        \"\"\"\n        return self.__class__(super().__add__(other))\n\n    def __radd__(self, other: bytes) -&gt; BinaPy:\n        \"\"\"Override base method so that right addition returns a BinaPy instead of bytes.\n\n        Args:\n            other: bytes or BinaPy to radd\n\n        Returns:\n            a BinaPy\n\n        \"\"\"\n        return self.__class__(other.__add__(self))\n\n    def split(self, sep: bytes | None = None, maxsplit: int = -1) -&gt; list[BinaPy]:  # type: ignore[override]\n        \"\"\"Override base method to return a BinaPy instead of bytes.\n\n        Args:\n            sep: a separator\n            maxsplit: the maximum number of splits\n\n        Returns:\n            a BinaPy\n\n        \"\"\"\n        return [self.__class__(b) for b in super().split(sep, maxsplit)]\n\n    def split_at(self, *pos: int) -&gt; tuple[BinaPy, ...]:\n        \"\"\"Split this BinaPy at one or more integer positions.\n\n        Args:\n            *pos: indexes where to cut the BinaPy\n\n        Returns:\n            a tuple of `len(pos) + 1` instances of BinaPy\n\n        \"\"\"\n        spos = sorted(pos)\n        return tuple(self.__class__(self[start:end]) for start, end in zip([0, *spos], [*spos, len(self)]))\n\n    cut_at = split_at  # for backward compatibility\n\n    extensions: ClassVar[dict[str, dict[str, Callable[..., Any]]]] = {}\n    \"\"\"Extension registry.\"\"\"\n\n    @classmethod\n    def _get_extension_methods(cls, name: str) -&gt; dict[str, Callable[..., Any]]:\n        extension = cls.extensions.get(name)\n        if extension is None:\n            msg = f\"Extension {name} not found\"\n            raise NotImplementedError(msg)\n        return extension\n\n    @classmethod\n    def _get_checker(cls, extension_name: str) -&gt; Callable[..., bool]:\n        extension_methods = cls._get_extension_methods(extension_name)\n        method = extension_methods.get(\"check\")\n        if method is None:\n            msg = f\"Extension '{extension_name}' does not have a checker method\"\n            raise NotImplementedError(msg)\n        return method\n\n    @classmethod\n    def _get_decoder(cls, extension_name: str) -&gt; Callable[..., BinaPy]:\n        extension_methods = cls._get_extension_methods(extension_name)\n        method = extension_methods.get(\"decode\")\n        if method is None:\n            msg = f\"Extension '{extension_name}' does not have a decode method\"\n            raise NotImplementedError(msg)\n        return method\n\n    @classmethod\n    def _get_encoder(cls, extension_name: str) -&gt; Callable[..., BinaPy]:\n        extension_methods = cls._get_extension_methods(extension_name)\n        method = extension_methods.get(\"encode\")\n        if method is None:\n            msg = f\"Extension '{extension_name}' does not have an encode method\"\n            raise NotImplementedError(msg)\n        return method\n\n    @classmethod\n    def _get_parser(cls, extension_name: str) -&gt; Callable[..., Any]:\n        extension_methods = cls._get_extension_methods(extension_name)\n        method = extension_methods.get(\"parse\")\n        if method is None:\n            msg = f\"Extension '{extension_name}' does not have a parse method\"\n            raise NotImplementedError(msg)\n        return method\n\n    @classmethod\n    def _get_serializer(cls, extension_name: str) -&gt; Callable[..., BinaPy]:\n        extension_methods = cls._get_extension_methods(extension_name)\n        method = extension_methods.get(\"serialize\")\n        if method is None:\n            msg = f\"Extension '{extension_name}' does not have a serialize method\"\n            raise NotImplementedError(msg)\n        return method\n\n    def encode_to(self, name: str, *args: Any, **kwargs: Any) -&gt; BinaPy:\n        \"\"\"Encode data from this BinaPy according to the format `name`.\n\n        Args:\n            name: format to use\n            *args: additional position parameters for the extension encoder method\n            **kwargs: additional keyword parameters for the extension encoder method\n\n        Returns:\n            the resulting data\n\n        \"\"\"\n        encoder = self._get_encoder(name)\n\n        return encoder(self, *args, **kwargs)\n\n    def to(self, name: str, *args: Any, **kwargs: Any) -&gt; BinaPy:\n        \"\"\"Alias for `encode_to()`.\n\n        Args:\n            name: same as `encode_to()`\n            *args:  same as `encode_to()`\n            **kwargs:  same as `encode_to()`\n\n        Returns:\n            same as `encode_to()`\n\n        \"\"\"\n        return self.encode_to(name, *args, **kwargs)\n\n    def decode_from(self, name: str, *args: Any, **kwargs: Any) -&gt; BinaPy:\n        \"\"\"Decode data from this BinaPy according to the format `name`.\n\n        Args:\n            name: format name to use\n            *args: additional position parameters for the extension decoder method\n            **kwargs: additional keyword parameters for the extension decoder method\n\n        Returns:\n            the resulting data\n\n        \"\"\"\n        decoder = self._get_decoder(name)\n\n        return decoder(self, *args, **kwargs)\n\n    def check(self, name: str, *, decode: bool = False, raise_on_error: bool = False) -&gt; bool:\n        \"\"\"Check that this BinaPy conforms to a given format extension.\n\n        Args:\n            name: the name of the extension to check\n            decode: if `True`, and the given extension does not have a checker method,\n                try to decode this BinaPy using the decoder method to check if that works.\n            raise_on_error: if `True`, exceptions from the checker method, if any,\n                will be raised instead of returning `False`.\n\n        Returns:\n            a boolean, that is True if this BinaPy conforms to the given extension format, False otherwise.\n\n        \"\"\"\n        # raises an exception in case the extension does not exist\n        self._get_extension_methods(name)\n\n        try:\n            checker = self._get_checker(name)\n            try:\n                return checker(self)\n            except InvalidExtensionMethodError:\n                raise\n            except Exception as exc:\n                if raise_on_error:\n                    raise exc from exc\n                return False\n        except NotImplementedError:\n            # if checker is not implemented and decode is True, try to decode instead\n            if decode:\n                decoder = self._get_decoder(name)\n                try:\n                    decoder(self)\n                except Exception as exc:\n                    if raise_on_error:\n                        raise exc from exc\n                    return False\n                else:\n                    return True\n            else:\n                raise\n        return False\n\n    def check_all(self, *, decode: bool = False) -&gt; list[str]:\n        \"\"\"Check if this BinaPy conforms to any of the registered format extensions.\n\n        Returns:\n             a list of format extensions that this BinaPy can be decoded from.\n\n        Args:\n            decode: if `True`, for extensions that don't have a checker method,\n                try to decode this BinaPy using the decoder method to check if that works.\n\n        \"\"\"\n\n        def get_results() -&gt; Iterator[str]:\n            for name in self.extensions:\n                with suppress(NotImplementedError):\n                    success = self.check(name, decode=decode)\n                    if success is True:\n                        yield name\n\n        return list(get_results())\n\n    def parse_from(self, name: str, *args: Any, **kwargs: Any) -&gt; Any:\n        \"\"\"Parse data from this BinaPy, based on a given format extension.\n\n        Args:\n            name: name of the extension to use\n            *args: additional position parameters for the extension decoder method\n            **kwargs: additional keyword parameters for the extension decoder method\n\n        Returns:\n            the result from parsing this BinaPy\n\n        \"\"\"\n        parser = self._get_parser(name)\n\n        return parser(self, *args, **kwargs)\n\n    @classmethod\n    def serialize_to(cls, name: str, *args: Any, **kwargs: Any) -&gt; BinaPy:\n        \"\"\"Serialize (dump) data to a BinaPy, based on a given extension format.\n\n        Args:\n            name: name of the extension to use\n            *args: additional position parameters\n                for the extension decoder method (which includes the data to serialize)\n            **kwargs: additional keyword parameters for the extension decoder method\n\n        Returns:\n            a BinaPy, resulting from serialization of the data\n\n        \"\"\"\n        serializer = cls._get_serializer(name)\n\n        return serializer(*args, **kwargs)\n\n    @classmethod\n    def register_extension(cls, name: str, feature: str, func: Callable[..., Any]) -&gt; None:\n        \"\"\"Register a new feature for the given extension name.\n\n        Args:\n            name: the extension name\n            feature: name of the feature to register (\"encode\", \"decode\", etc.)\n            func: the method implementing the feature\n\n        \"\"\"\n        ext_dict = cls.extensions.setdefault(name, {})\n        ext_dict[feature] = func\n</code></pre>"},{"location":"api/#binapy.BinaPy.extensions","title":"<code>extensions: dict[str, dict[str, Callable[..., Any]]] = {}</code>  <code>class-attribute</code>","text":"<p>Extension registry.</p>"},{"location":"api/#binapy.BinaPy.from_int","title":"<code>from_int(i, *, length=None, byteorder='big', signed=False)</code>  <code>classmethod</code>","text":"<p>Convert an <code>int</code> to a <code>BinaPy</code>.</p> <p>This is a wrapper around int.to_bytes() and takes the same parameters.</p> <p>Parameters:</p> Name Type Description Default <code>i</code> <code>int</code> <p>the integer to convert to BinaPy</p> required <code>length</code> <code>int | None</code> <p>the length of the integer, in bytes. If omitted,default to the minimal length that fits the given integer.</p> <code>None</code> <code>byteorder</code> <code>Literal['little', 'big']</code> <p>\"little\" or \"big\" (defaults to \"big\")</p> <code>'big'</code> <code>signed</code> <code>bool</code> <p>determines whether two's complement is used to represent the integer.</p> <code>False</code> <p>Returns:</p> Type Description <code>BinaPy</code> <p>a BinaPy with the binary representation of the given integer</p> Source code in <code>binapy/binapy.py</code> <pre><code>@classmethod\ndef from_int(\n    cls,\n    i: int,\n    *,\n    length: int | None = None,\n    byteorder: Literal[\"little\", \"big\"] = \"big\",\n    signed: bool = False,\n) -&gt; BinaPy:\n    \"\"\"Convert an `int` to a `BinaPy`.\n\n    This is a wrapper around [int.to_bytes()](https://docs.python.org/3/library/stdtypes.html#int.to_bytes) and\n    takes the same parameters.\n\n    Args:\n        i: the integer to convert to BinaPy\n        length: the length of the integer, in bytes.\n          If omitted,default to the minimal length that fits the given integer.\n        byteorder: \"little\" or \"big\" (defaults to \"big\")\n        signed: determines whether two's complement is used to represent the integer.\n\n    Returns:\n        a BinaPy with the binary representation of the given integer\n\n    \"\"\"\n    if length is None:\n        length = (i.bit_length() + 7) // 8\n\n    data = i.to_bytes(length, byteorder, signed=signed)\n    return cls(data)\n</code></pre>"},{"location":"api/#binapy.BinaPy.ascii","title":"<code>ascii()</code>","text":"<p>Decode this BinaPy to a str.</p> <p>This makes sure that only ascii characters are part of the result.</p> <p>Returns:</p> Type Description <code>str</code> <p>a str with only ASCII chars</p> Source code in <code>binapy/binapy.py</code> <pre><code>def ascii(self) -&gt; str:\n    \"\"\"Decode this BinaPy to a str.\n\n    This makes sure that only ascii characters are part of the result.\n\n    Returns:\n        a str with only ASCII chars\n\n    \"\"\"\n    return self.decode(\"ascii\")\n</code></pre>"},{"location":"api/#binapy.BinaPy.re_match","title":"<code>re_match(pattern, encoding='ascii')</code>","text":"<p>Decode this binary value to a string, then match it to a regex.</p> <p>Decoding is done using the encoding defined in <code>encoding</code> (default to \"ascii\"). The decoded value is then matched with the regular expression <code>pattern</code>.</p> <p>If the match is successful, return the decoded string. Raise a <code>ValueError</code> otherwise.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>str</code> <p>the regular expression pattern to match</p> required <code>encoding</code> <code>str</code> <p>the encoding to use to decode the binary value to a string</p> <code>'ascii'</code> <p>Returns:</p> Type Description <code>str</code> <p>the decoded, matching <code>str</code></p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if the decoded str does not match <code>pattern</code></p> Source code in <code>binapy/binapy.py</code> <pre><code>def re_match(self, pattern: str, encoding: str = \"ascii\") -&gt; str:\n    \"\"\"Decode this binary value to a string, then match it to a regex.\n\n    Decoding is done using the encoding defined in `encoding` (default to \"ascii\").\n    The decoded value is then matched with the regular expression `pattern`.\n\n    If the match is successful, return the decoded string. Raise a `ValueError` otherwise.\n\n    Args:\n        pattern: the regular expression pattern to match\n        encoding: the encoding to use to decode the binary value to a string\n\n    Returns:\n        the decoded, matching `str`\n\n    Raises:\n        ValueError: if the decoded str does not match `pattern`\n\n    \"\"\"\n    res = self.decode(encoding)\n    if re.match(pattern, res):\n        return res\n    msg = f\"This value does not match pattern {pattern}\"\n    raise ValueError(msg)\n</code></pre>"},{"location":"api/#binapy.BinaPy.text","title":"<code>text(encoding='ascii')</code>","text":"<p>Decode this BinaPy to a str, and check that the result is printable.</p> <p>Printable characters are characters from the range <code>[a-zA-Z0-9!\"#$%&amp;\\'()*+,-./:;&lt;=&gt;?@[\\\\]^_</code>~ ]`.</p> <p>Parameters:</p> Name Type Description Default <code>encoding</code> <code>str</code> <p>the encoding to use to decode the binary data</p> <code>'ascii'</code> <p>Returns:</p> Type Description <code>str</code> <p>the decoded text</p> Source code in <code>binapy/binapy.py</code> <pre><code>def text(self, encoding: str = \"ascii\") -&gt; str:\n    r\"\"\"Decode this BinaPy to a str, and check that the result is printable.\n\n    Printable characters are characters from the range `[a-zA-Z0-9!\"#$%&amp;\\'()*+,-./:;&lt;=&gt;?@[\\\\]^_`{|}~ ]`.\n\n    Args:\n        encoding: the encoding to use to decode the binary data\n\n    Returns:\n        the decoded text\n\n    \"\"\"\n    return self.re_match(r'^[a-zA-Z0-9!\"#$%&amp;\\'()*+,-./:;&lt;=&gt;?@[\\\\]^_`{|}~ ]*$', encoding)\n</code></pre>"},{"location":"api/#binapy.BinaPy.urlsafe","title":"<code>urlsafe()</code>","text":"<p>Convert this BinaPy to a str, and check that it contains only url-safe characters.</p> <p>Url-safe characters are <code>[A-Za-z0-9_.\\\\-~]</code>.</p> <p>Returns:</p> Type Description <code>str</code> <p>a str with only URL-safe chars</p> Source code in <code>binapy/binapy.py</code> <pre><code>def urlsafe(self) -&gt; str:\n    r\"\"\"Convert this BinaPy to a str, and check that it contains only url-safe characters.\n\n    Url-safe characters are `[A-Za-z0-9_.\\\\-~]`.\n\n    Returns:\n             a str with only URL-safe chars\n\n    \"\"\"\n    return self.re_match(r\"^[A-Za-z0-9_.\\-~]$\")\n</code></pre>"},{"location":"api/#binapy.BinaPy.alphanumeric","title":"<code>alphanumeric()</code>","text":"<p>Check that this BinaPy contains only alphanumeric characters.</p> <p>Returns:</p> Type Description <code>str</code> <p>a str with only alphanumeric chars</p> Source code in <code>binapy/binapy.py</code> <pre><code>def alphanumeric(self) -&gt; str:\n    \"\"\"Check that this BinaPy contains only alphanumeric characters.\n\n    Returns:\n             a str with only alphanumeric chars\n\n    \"\"\"\n    return self.re_match(r\"^[a-zA-Z]$\")\n</code></pre>"},{"location":"api/#binapy.BinaPy.to_int","title":"<code>to_int(*, byteorder='big', signed=False)</code>","text":"<p>Convert this BinaPy to an <code>int</code>.</p> <p>This is a wrapper around int.from_bytes() and takes the same parameters.</p> <p>Parameters:</p> Name Type Description Default <code>byteorder</code> <code>Literal['little', 'big']</code> <p>\"little\" or \"big\" (defaults to \"big\")</p> <code>'big'</code> <code>signed</code> <code>bool</code> <p>determines whether two's complement is used to represent the integer. Default to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>int</code> <p>an integer based on this BinaPy binary value</p> Source code in <code>binapy/binapy.py</code> <pre><code>def to_int(self, *, byteorder: Literal[\"little\", \"big\"] = \"big\", signed: bool = False) -&gt; int:\n    \"\"\"Convert this BinaPy to an `int`.\n\n    This is a wrapper around\n    [int.from_bytes()](https://docs.python.org/3/library/stdtypes.html#int.from_bytes) and takes\n    the same parameters.\n\n    Args:\n        byteorder: \"little\" or \"big\" (defaults to \"big\")\n        signed: determines whether two's complement is used to represent the integer. Default to False.\n\n    Returns:\n        an integer based on this BinaPy binary value\n\n    \"\"\"\n    return int.from_bytes(self, byteorder, signed=signed)\n</code></pre>"},{"location":"api/#binapy.BinaPy.from_binary_string","title":"<code>from_binary_string(s, *, byteorder='big', signed=False)</code>  <code>classmethod</code>","text":"<p>Initialize a BinaPy based on a binary string (containing only 0 and 1).</p> <p>The string may contain spaces or tabs characters which will be ignored.</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>str</code> <p>a binary string</p> required <code>byteorder</code> <code>Literal['little', 'big']</code> <p>byte order to use</p> <code>'big'</code> <code>signed</code> <code>bool</code> <p>True if 2 complement is used to represent negative values</p> <code>False</code> <p>Returns:</p> Type Description <code>BinaPy</code> <p>a BinaPy</p> Source code in <code>binapy/binapy.py</code> <pre><code>@classmethod\ndef from_binary_string(cls, s: str, *, byteorder: Literal[\"little\", \"big\"] = \"big\", signed: bool = False) -&gt; BinaPy:\n    \"\"\"Initialize a BinaPy based on a binary string (containing only 0 and 1).\n\n    The string may contain spaces or tabs characters which will be ignored.\n\n    Args:\n        s: a binary string\n        byteorder: byte order to use\n        signed: True if 2 complement is used to represent negative values\n\n    Returns:\n        a BinaPy\n\n    \"\"\"\n    s = s.replace(\" \", \"\").replace(\"\\t\", \"\")\n    return cls(int(s, 2).to_bytes((len(s) + 7) // 8, byteorder=byteorder, signed=signed))\n</code></pre>"},{"location":"api/#binapy.BinaPy.to_binary_string","title":"<code>to_binary_string(*, byteorder='big', signed=False, pad=True)</code>","text":"<p>Return a string containing this BinaPy value in binary representation.</p> <p>Parameters:</p> Name Type Description Default <code>byteorder</code> <code>Literal['little', 'big']</code> <p>byte order to use</p> <code>'big'</code> <code>signed</code> <code>bool</code> <p><code>True</code> if 2 complement is used to represent negative values</p> <code>False</code> <code>pad</code> <code>bool</code> <p>if <code>True</code>, left pad the result with 0 to make length a multiple of 8</p> <code>True</code> <p>Returns:</p> Type Description <code>str</code> <p>a string with containing only 0 and 1</p> Source code in <code>binapy/binapy.py</code> <pre><code>def to_binary_string(\n    self,\n    *,\n    byteorder: Literal[\"little\", \"big\"] = \"big\",\n    signed: bool = False,\n    pad: bool = True,\n) -&gt; str:\n    \"\"\"Return a string containing this BinaPy value in binary representation.\n\n    Args:\n        byteorder: byte order to use\n        signed: `True` if 2 complement is used to represent negative values\n        pad: if `True`, left pad the result with 0 to make length a multiple of 8\n\n    Returns:\n        a string with containing only 0 and 1\n\n    \"\"\"\n    binary = format(self.to_int(byteorder=byteorder, signed=signed), \"b\")\n    if pad and len(binary) % 8:\n        d = len(binary) // 8\n        return binary.rjust(8 * d + 8, \"0\")\n    return binary\n</code></pre>"},{"location":"api/#binapy.BinaPy.random","title":"<code>random(length)</code>  <code>classmethod</code>","text":"<p>Return a BinaPy containing <code>length</code> random bytes.</p> <p>Parameters:</p> Name Type Description Default <code>length</code> <code>int</code> <p>number of bytes to generate</p> required <p>Returns:</p> Type Description <code>BinaPy</code> <p>a BinaPy with randomly generated data</p> Source code in <code>binapy/binapy.py</code> <pre><code>@classmethod\ndef random(cls, length: int) -&gt; BinaPy:\n    \"\"\"Return a BinaPy containing `length` random bytes.\n\n    Args:\n        length: number of bytes to generate\n\n    Returns:\n        a BinaPy with randomly generated data\n\n    \"\"\"\n    return cls(secrets.token_bytes(length))\n</code></pre>"},{"location":"api/#binapy.BinaPy.random_bits","title":"<code>random_bits(length)</code>  <code>classmethod</code>","text":"<p>Return a BinaPy containing <code>length</code> random bits. Same as random(length//8).</p> <p>Length must be a multiple of 8.</p> <p>Parameters:</p> Name Type Description Default <code>length</code> <code>int</code> <p>number of bits to randomly generate</p> required <p>Returns:</p> Type Description <code>BinaPy</code> <p>a BinaPy with randomly generated data</p> Source code in <code>binapy/binapy.py</code> <pre><code>@classmethod\ndef random_bits(cls, length: int) -&gt; BinaPy:\n    \"\"\"Return a BinaPy containing `length` random bits. Same as random(length//8).\n\n    Length must be a multiple of 8.\n\n    Args:\n        length: number of bits to randomly generate\n\n    Returns:\n        a BinaPy with randomly generated data\n\n    \"\"\"\n    return cls(secrets.token_bytes(length // 8))\n</code></pre>"},{"location":"api/#binapy.BinaPy.char_at","title":"<code>char_at(index)</code>","text":"<p>Return the character at the given index.</p> <p>Slicing a standard bytes returns an int. Sometimes what you really want is a single char string.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>the index of the desired character</p> required <p>Returns:</p> Type Description <code>str</code> <p>the single character at the given index</p> Source code in <code>binapy/binapy.py</code> <pre><code>def char_at(self, index: int) -&gt; str:\n    \"\"\"Return the character at the given index.\n\n    Slicing a standard bytes returns an int. Sometimes what you really want is a single char string.\n\n    Args:\n        index: the index of the desired character\n\n    Returns:\n        the single character at the given index\n\n    \"\"\"\n    return chr(self[index])\n</code></pre>"},{"location":"api/#binapy.BinaPy.split","title":"<code>split(sep=None, maxsplit=-1)</code>","text":"<p>Override base method to return a BinaPy instead of bytes.</p> <p>Parameters:</p> Name Type Description Default <code>sep</code> <code>bytes | None</code> <p>a separator</p> <code>None</code> <code>maxsplit</code> <code>int</code> <p>the maximum number of splits</p> <code>-1</code> <p>Returns:</p> Type Description <code>list[BinaPy]</code> <p>a BinaPy</p> Source code in <code>binapy/binapy.py</code> <pre><code>def split(self, sep: bytes | None = None, maxsplit: int = -1) -&gt; list[BinaPy]:  # type: ignore[override]\n    \"\"\"Override base method to return a BinaPy instead of bytes.\n\n    Args:\n        sep: a separator\n        maxsplit: the maximum number of splits\n\n    Returns:\n        a BinaPy\n\n    \"\"\"\n    return [self.__class__(b) for b in super().split(sep, maxsplit)]\n</code></pre>"},{"location":"api/#binapy.BinaPy.split_at","title":"<code>split_at(*pos)</code>","text":"<p>Split this BinaPy at one or more integer positions.</p> <p>Parameters:</p> Name Type Description Default <code>*pos</code> <code>int</code> <p>indexes where to cut the BinaPy</p> <code>()</code> <p>Returns:</p> Type Description <code>tuple[BinaPy, ...]</code> <p>a tuple of <code>len(pos) + 1</code> instances of BinaPy</p> Source code in <code>binapy/binapy.py</code> <pre><code>def split_at(self, *pos: int) -&gt; tuple[BinaPy, ...]:\n    \"\"\"Split this BinaPy at one or more integer positions.\n\n    Args:\n        *pos: indexes where to cut the BinaPy\n\n    Returns:\n        a tuple of `len(pos) + 1` instances of BinaPy\n\n    \"\"\"\n    spos = sorted(pos)\n    return tuple(self.__class__(self[start:end]) for start, end in zip([0, *spos], [*spos, len(self)]))\n</code></pre>"},{"location":"api/#binapy.BinaPy.encode_to","title":"<code>encode_to(name, *args, **kwargs)</code>","text":"<p>Encode data from this BinaPy according to the format <code>name</code>.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>format to use</p> required <code>*args</code> <code>Any</code> <p>additional position parameters for the extension encoder method</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>additional keyword parameters for the extension encoder method</p> <code>{}</code> <p>Returns:</p> Type Description <code>BinaPy</code> <p>the resulting data</p> Source code in <code>binapy/binapy.py</code> <pre><code>def encode_to(self, name: str, *args: Any, **kwargs: Any) -&gt; BinaPy:\n    \"\"\"Encode data from this BinaPy according to the format `name`.\n\n    Args:\n        name: format to use\n        *args: additional position parameters for the extension encoder method\n        **kwargs: additional keyword parameters for the extension encoder method\n\n    Returns:\n        the resulting data\n\n    \"\"\"\n    encoder = self._get_encoder(name)\n\n    return encoder(self, *args, **kwargs)\n</code></pre>"},{"location":"api/#binapy.BinaPy.to","title":"<code>to(name, *args, **kwargs)</code>","text":"<p>Alias for <code>encode_to()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>same as <code>encode_to()</code></p> required <code>*args</code> <code>Any</code> <p>same as <code>encode_to()</code></p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>same as <code>encode_to()</code></p> <code>{}</code> <p>Returns:</p> Type Description <code>BinaPy</code> <p>same as <code>encode_to()</code></p> Source code in <code>binapy/binapy.py</code> <pre><code>def to(self, name: str, *args: Any, **kwargs: Any) -&gt; BinaPy:\n    \"\"\"Alias for `encode_to()`.\n\n    Args:\n        name: same as `encode_to()`\n        *args:  same as `encode_to()`\n        **kwargs:  same as `encode_to()`\n\n    Returns:\n        same as `encode_to()`\n\n    \"\"\"\n    return self.encode_to(name, *args, **kwargs)\n</code></pre>"},{"location":"api/#binapy.BinaPy.decode_from","title":"<code>decode_from(name, *args, **kwargs)</code>","text":"<p>Decode data from this BinaPy according to the format <code>name</code>.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>format name to use</p> required <code>*args</code> <code>Any</code> <p>additional position parameters for the extension decoder method</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>additional keyword parameters for the extension decoder method</p> <code>{}</code> <p>Returns:</p> Type Description <code>BinaPy</code> <p>the resulting data</p> Source code in <code>binapy/binapy.py</code> <pre><code>def decode_from(self, name: str, *args: Any, **kwargs: Any) -&gt; BinaPy:\n    \"\"\"Decode data from this BinaPy according to the format `name`.\n\n    Args:\n        name: format name to use\n        *args: additional position parameters for the extension decoder method\n        **kwargs: additional keyword parameters for the extension decoder method\n\n    Returns:\n        the resulting data\n\n    \"\"\"\n    decoder = self._get_decoder(name)\n\n    return decoder(self, *args, **kwargs)\n</code></pre>"},{"location":"api/#binapy.BinaPy.check","title":"<code>check(name, *, decode=False, raise_on_error=False)</code>","text":"<p>Check that this BinaPy conforms to a given format extension.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>the name of the extension to check</p> required <code>decode</code> <code>bool</code> <p>if <code>True</code>, and the given extension does not have a checker method, try to decode this BinaPy using the decoder method to check if that works.</p> <code>False</code> <code>raise_on_error</code> <code>bool</code> <p>if <code>True</code>, exceptions from the checker method, if any, will be raised instead of returning <code>False</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>bool</code> <p>a boolean, that is True if this BinaPy conforms to the given extension format, False otherwise.</p> Source code in <code>binapy/binapy.py</code> <pre><code>def check(self, name: str, *, decode: bool = False, raise_on_error: bool = False) -&gt; bool:\n    \"\"\"Check that this BinaPy conforms to a given format extension.\n\n    Args:\n        name: the name of the extension to check\n        decode: if `True`, and the given extension does not have a checker method,\n            try to decode this BinaPy using the decoder method to check if that works.\n        raise_on_error: if `True`, exceptions from the checker method, if any,\n            will be raised instead of returning `False`.\n\n    Returns:\n        a boolean, that is True if this BinaPy conforms to the given extension format, False otherwise.\n\n    \"\"\"\n    # raises an exception in case the extension does not exist\n    self._get_extension_methods(name)\n\n    try:\n        checker = self._get_checker(name)\n        try:\n            return checker(self)\n        except InvalidExtensionMethodError:\n            raise\n        except Exception as exc:\n            if raise_on_error:\n                raise exc from exc\n            return False\n    except NotImplementedError:\n        # if checker is not implemented and decode is True, try to decode instead\n        if decode:\n            decoder = self._get_decoder(name)\n            try:\n                decoder(self)\n            except Exception as exc:\n                if raise_on_error:\n                    raise exc from exc\n                return False\n            else:\n                return True\n        else:\n            raise\n    return False\n</code></pre>"},{"location":"api/#binapy.BinaPy.check_all","title":"<code>check_all(*, decode=False)</code>","text":"<p>Check if this BinaPy conforms to any of the registered format extensions.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>a list of format extensions that this BinaPy can be decoded from.</p> <p>Parameters:</p> Name Type Description Default <code>decode</code> <code>bool</code> <p>if <code>True</code>, for extensions that don't have a checker method, try to decode this BinaPy using the decoder method to check if that works.</p> <code>False</code> Source code in <code>binapy/binapy.py</code> <pre><code>def check_all(self, *, decode: bool = False) -&gt; list[str]:\n    \"\"\"Check if this BinaPy conforms to any of the registered format extensions.\n\n    Returns:\n         a list of format extensions that this BinaPy can be decoded from.\n\n    Args:\n        decode: if `True`, for extensions that don't have a checker method,\n            try to decode this BinaPy using the decoder method to check if that works.\n\n    \"\"\"\n\n    def get_results() -&gt; Iterator[str]:\n        for name in self.extensions:\n            with suppress(NotImplementedError):\n                success = self.check(name, decode=decode)\n                if success is True:\n                    yield name\n\n    return list(get_results())\n</code></pre>"},{"location":"api/#binapy.BinaPy.parse_from","title":"<code>parse_from(name, *args, **kwargs)</code>","text":"<p>Parse data from this BinaPy, based on a given format extension.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of the extension to use</p> required <code>*args</code> <code>Any</code> <p>additional position parameters for the extension decoder method</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>additional keyword parameters for the extension decoder method</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>the result from parsing this BinaPy</p> Source code in <code>binapy/binapy.py</code> <pre><code>def parse_from(self, name: str, *args: Any, **kwargs: Any) -&gt; Any:\n    \"\"\"Parse data from this BinaPy, based on a given format extension.\n\n    Args:\n        name: name of the extension to use\n        *args: additional position parameters for the extension decoder method\n        **kwargs: additional keyword parameters for the extension decoder method\n\n    Returns:\n        the result from parsing this BinaPy\n\n    \"\"\"\n    parser = self._get_parser(name)\n\n    return parser(self, *args, **kwargs)\n</code></pre>"},{"location":"api/#binapy.BinaPy.serialize_to","title":"<code>serialize_to(name, *args, **kwargs)</code>  <code>classmethod</code>","text":"<p>Serialize (dump) data to a BinaPy, based on a given extension format.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of the extension to use</p> required <code>*args</code> <code>Any</code> <p>additional position parameters for the extension decoder method (which includes the data to serialize)</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>additional keyword parameters for the extension decoder method</p> <code>{}</code> <p>Returns:</p> Type Description <code>BinaPy</code> <p>a BinaPy, resulting from serialization of the data</p> Source code in <code>binapy/binapy.py</code> <pre><code>@classmethod\ndef serialize_to(cls, name: str, *args: Any, **kwargs: Any) -&gt; BinaPy:\n    \"\"\"Serialize (dump) data to a BinaPy, based on a given extension format.\n\n    Args:\n        name: name of the extension to use\n        *args: additional position parameters\n            for the extension decoder method (which includes the data to serialize)\n        **kwargs: additional keyword parameters for the extension decoder method\n\n    Returns:\n        a BinaPy, resulting from serialization of the data\n\n    \"\"\"\n    serializer = cls._get_serializer(name)\n\n    return serializer(*args, **kwargs)\n</code></pre>"},{"location":"api/#binapy.BinaPy.register_extension","title":"<code>register_extension(name, feature, func)</code>  <code>classmethod</code>","text":"<p>Register a new feature for the given extension name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>the extension name</p> required <code>feature</code> <code>str</code> <p>name of the feature to register (\"encode\", \"decode\", etc.)</p> required <code>func</code> <code>Callable[..., Any]</code> <p>the method implementing the feature</p> required Source code in <code>binapy/binapy.py</code> <pre><code>@classmethod\ndef register_extension(cls, name: str, feature: str, func: Callable[..., Any]) -&gt; None:\n    \"\"\"Register a new feature for the given extension name.\n\n    Args:\n        name: the extension name\n        feature: name of the feature to register (\"encode\", \"decode\", etc.)\n        func: the method implementing the feature\n\n    \"\"\"\n    ext_dict = cls.extensions.setdefault(name, {})\n    ext_dict[feature] = func\n</code></pre>"},{"location":"api/#binapy.InvalidExtensionMethodError","title":"<code>InvalidExtensionMethodError</code>","text":"<p>             Bases: <code>ValueError</code></p> <p>Raised when an extension method returns invalid data.</p> Source code in <code>binapy/binapy.py</code> <pre><code>class InvalidExtensionMethodError(ValueError):\n    \"\"\"Raised when an extension method returns invalid data.\"\"\"\n</code></pre>"},{"location":"api/#binapy.binapy_checker","title":"<code>binapy_checker(name)</code>","text":"<p>Declare a new checker for BinaPy.</p> <p>This is a decorator. Checker checks that some data is valid for a given format/extension.</p> <pre><code>name: name of the extension\n</code></pre> <pre><code>a method decorator\n</code></pre> Usage <p>The matching checker for the special \"double-encoding\" we created with <code>binapy_encoder()</code>:</p> <pre><code>from binapy import binapy_checker\n\n\n@binapy_checker(\"double\")\ndef double_check(data: bytes) -&gt; bytes:\n    return len(data) % 2 == 0 and data[: len(data) // 2] == data[len(data) // 2 :]\n\n\nassert BinaPy(b\"abcabc\").check(\"double\")\n</code></pre> Source code in <code>binapy/binapy.py</code> <pre><code>def binapy_checker(name: str) -&gt; Callable[[F], F]:\n    \"\"\"Declare a new checker for BinaPy.\n\n    This is a decorator. Checker checks that some data is valid for a given format/extension.\n\n    Args:\n    ----\n        name: name of the extension\n\n    Returns:\n    -------\n        a method decorator\n\n    Usage:\n        The matching checker for the special \"double-encoding\" we created with `binapy_encoder()`:\n\n        ```python\n        from binapy import binapy_checker\n\n\n        @binapy_checker(\"double\")\n        def double_check(data: bytes) -&gt; bytes:\n            return len(data) % 2 == 0 and data[: len(data) // 2] == data[len(data) // 2 :]\n\n\n        assert BinaPy(b\"abcabc\").check(\"double\")\n        ```\n\n    \"\"\"\n\n    def decorator(func: F) -&gt; F:\n        @wraps(func)\n        def wrapper(*args: Any, **kwargs: Any) -&gt; bool:\n            raw_result = func(*args, **kwargs)\n\n            if not isinstance(raw_result, bool):\n                msg = f\"extension {name} checker method did not return boolean data\"\n                raise InvalidExtensionMethodError(msg)\n            return raw_result\n\n        BinaPy.register_extension(name, \"check\", wrapper)\n        return cast(F, wrapper)\n\n    return decorator\n</code></pre>"},{"location":"api/#binapy.binapy_decoder","title":"<code>binapy_decoder(name)</code>","text":"<p>Declare a new decoder for BinaPy.</p> <p>This is a method decorator. Decoders do convert BinaPy data from a given format into another BinaPy.</p> <pre><code>name: name of the extension\n</code></pre> <pre><code>a method decorator\n</code></pre> Usage <p>The matching decoder for the special \"double-encoding\" we created with <code>binapy_encoder()</code>:</p> <pre><code>from binapy import binapy_decoder\n\n\n@binapy_decoder(\"double\")\ndef double_decode(data: bytes) -&gt; bytes:\n    if len(data) % 2 or data[: len(data) // 2] != data[len(data) // 2 :]:\n        raise ValueError(\"This is not a double-encoded data!\")\n    return data[: len(data) // 2]\n\n\nassert BinaPy(b\"abcabc\").decode_from(\"double\") == b\"abc\"\n</code></pre> Source code in <code>binapy/binapy.py</code> <pre><code>def binapy_decoder(name: str) -&gt; Callable[[F], F]:\n    \"\"\"Declare a new decoder for BinaPy.\n\n    This is a method decorator. Decoders do convert BinaPy data from a given format into another BinaPy.\n\n    Args:\n    ----\n        name: name of the extension\n\n    Returns:\n    -------\n        a method decorator\n\n    Usage:\n        The matching decoder for the special \"double-encoding\" we created with `binapy_encoder()`:\n\n        ```python\n        from binapy import binapy_decoder\n\n\n        @binapy_decoder(\"double\")\n        def double_decode(data: bytes) -&gt; bytes:\n            if len(data) % 2 or data[: len(data) // 2] != data[len(data) // 2 :]:\n                raise ValueError(\"This is not a double-encoded data!\")\n            return data[: len(data) // 2]\n\n\n        assert BinaPy(b\"abcabc\").decode_from(\"double\") == b\"abc\"\n        ```\n\n    \"\"\"\n\n    def decorator(func: F) -&gt; F:\n        @wraps(func)\n        def wrapper(*args: Any, **kwargs: Any) -&gt; BinaPy:\n            raw_result = func(*args, **kwargs)\n            if not isinstance(raw_result, (bytes, bytearray)):\n                msg = f\"extension {name} decoder method did not return binary data\"\n                raise InvalidExtensionMethodError(msg)\n            return BinaPy(raw_result)\n\n        BinaPy.register_extension(name, \"decode\", wrapper)\n        return cast(F, wrapper)\n\n    return decorator\n</code></pre>"},{"location":"api/#binapy.binapy_encoder","title":"<code>binapy_encoder(name)</code>","text":"<p>Declare new encoders for BinaPy.</p> <p>This is a method decorator. Encoders do convert a BinaPy into another BinaPy using a given format/extension.</p> <pre><code>name: name of the extension\n</code></pre> <pre><code>a method decorator\n</code></pre> Usage <p>To declare a special \"double-encoding\" which just copy the data twice:</p> <pre><code>from binapy import binapy_encoder\n\n\n@binapy_encoder(\"double\")\ndef double_encode(data: bytes) -&gt; bytes:\n    return data * 2\n\n\nassert BinaPy(b\"abc\").to(\"double\") == b\"abcabc\"\n</code></pre> Source code in <code>binapy/binapy.py</code> <pre><code>def binapy_encoder(name: str) -&gt; Callable[[F], F]:\n    \"\"\"Declare new encoders for BinaPy.\n\n    This is a method decorator. Encoders do convert a BinaPy into another BinaPy using a given format/extension.\n\n    Args:\n    ----\n        name: name of the extension\n\n    Returns:\n    -------\n        a method decorator\n\n    Usage:\n        To declare a special \"double-encoding\" which just copy the data twice:\n\n        ```python\n        from binapy import binapy_encoder\n\n\n        @binapy_encoder(\"double\")\n        def double_encode(data: bytes) -&gt; bytes:\n            return data * 2\n\n\n        assert BinaPy(b\"abc\").to(\"double\") == b\"abcabc\"\n        ```\n\n    \"\"\"\n\n    def decorator(func: F) -&gt; F:\n        @wraps(func)\n        def wrapper(*args: Any, **kwargs: Any) -&gt; BinaPy:\n            raw_result = func(*args, **kwargs)\n            if not isinstance(raw_result, (bytes, bytearray, str)):\n                msg = f\"extension {name} encoder method did not return binary data\"\n                raise InvalidExtensionMethodError(msg)\n            return BinaPy(raw_result)\n\n        BinaPy.register_extension(name, \"encode\", wrapper)\n        return cast(F, wrapper)\n\n    return decorator\n</code></pre>"},{"location":"api/#binapy.binapy_parser","title":"<code>binapy_parser(name)</code>","text":"<p>Declare a new parser for BinaPy.</p> <p>This is a method decorator. Parsers do convert BinaPy into Python objects. For example, a JSON parser will convert a BinaPy into a dict, by parsing the JSON formatted string from a BinaPy.</p> <pre><code>name: the extension name to use\n</code></pre> <pre><code>a method decorator\n</code></pre> Source code in <code>binapy/binapy.py</code> <pre><code>def binapy_parser(name: str) -&gt; Callable[[F], F]:\n    \"\"\"Declare a new parser for BinaPy.\n\n    This is a method decorator. Parsers do convert BinaPy into Python objects.\n    For example, a JSON parser will convert a BinaPy into a dict, by parsing the JSON formatted string from a BinaPy.\n\n    Args:\n    ----\n        name: the extension name to use\n\n    Returns:\n    -------\n        a method decorator\n\n    \"\"\"\n\n    def decorator(func: Callable[..., Any]) -&gt; Any:\n        BinaPy.register_extension(name, \"parse\", func)\n        return func\n\n    return decorator\n</code></pre>"},{"location":"api/#binapy.binapy_serializer","title":"<code>binapy_serializer(name)</code>","text":"<p>Declare a new serializer for BinaPy.</p> <p>This is a method decorator. Serializers do convert Python objects into BinaPy. For example, a JSON serializer will convert a Python <code>dict</code> into a serialized JSON value.</p> <pre><code>name: extension name to use\n</code></pre> <pre><code>a method decorator\n</code></pre> Source code in <code>binapy/binapy.py</code> <pre><code>def binapy_serializer(name: str) -&gt; Callable[[F], F]:\n    \"\"\"Declare a new serializer for BinaPy.\n\n    This is a method decorator. Serializers do convert Python objects into BinaPy.\n    For example, a JSON serializer will convert a Python `dict` into a serialized JSON value.\n\n    Args:\n    ----\n        name: extension name to use\n\n    Returns:\n    -------\n        a method decorator\n\n    \"\"\"\n\n    def decorator(func: F) -&gt; F:\n        @wraps(func)\n        def wrapper(*args: Any, **kwargs: Any) -&gt; BinaPy:\n            raw_result = func(*args, **kwargs)\n            if not isinstance(raw_result, (bytes, bytearray)):\n                msg = f\"extension {name} serializer method did not return binary data\"\n                raise InvalidExtensionMethodError(msg)\n            return BinaPy(raw_result)\n\n        BinaPy.register_extension(name, \"serialize\", wrapper)\n        return cast(F, wrapper)\n\n    return decorator\n</code></pre>"},{"location":"authors/","title":"authors","text":"<p>{% include-markdown \"../AUTHORS.md\" %}</p>"},{"location":"contributing/","title":"contributing","text":"<p>{% include-markdown \"../CONTRIBUTING.md\" %}</p>"},{"location":"history/","title":"history","text":"<p>{% include-markdown \"../HISTORY.md\" %}</p>"},{"location":"installation/","title":"installation","text":""},{"location":"installation/#installation","title":"Installation","text":""},{"location":"installation/#stable-release","title":"Stable release","text":"<p>To install BinaPy, run this command in your terminal:</p> <pre><code>$ pip install binapy\n</code></pre> <p>This is the preferred method to install BinaPy, as it will always install the most recent stable release.</p> <p>If you don't have pip installed, this Python installation guide can guide you through the process.</p>"},{"location":"installation/#from-source","title":"From source","text":"<p>The source for BinaPy can be downloaded from the Github repo.</p> <p>You can either clone the public repository:</p> <pre><code>$ git clone git://github.com/guillp/binapy\n</code></pre> <p>Or download the tarball:</p> <pre><code>$ curl -OJL https://github.com/guillp/binapy/tarball/master\n</code></pre> <p>Once you have a copy of the source, you can install it with:</p> <pre><code>$ pip install .\n</code></pre>"},{"location":"usage/","title":"usage","text":""},{"location":"usage/#usage","title":"Usage","text":""},{"location":"usage/#import","title":"Import","text":"<p>To use BinaPy in a project, import the main class like this:</p> <pre><code>from binapy import BinaPy\n</code></pre> <p><code>BinaPy</code> is a subclass of Python's built-in <code>bytes</code>, so you can use it anywhere a <code>bytes</code> is required. You may also <code>.decode()</code> it to convert it to a <code>str</code>, or use any of the default methods from <code>bytes</code> It also provides a few additional convenience methods, such as <code>cut_at(*pos)</code>, <code>.ascii()</code>, etc.</p>"},{"location":"usage/#initialize","title":"Initialize","text":"<p>To initialize a <code>BinaPy</code>:</p> <ul> <li>from a <code>bytes</code>: <code>bp = BinaPy(b'my raw bytes \\x01\\xcf'</code>)</li> <li>from a <code>str</code>: <code>bp = BinaPy(\"my string\", encoding='cp1252')</code>. If <code>encoding</code> is omitted, it will default to <code>'utf-8'</code>. That is a different to the <code>bytes</code> constructor where encoding is mandatory when you give it a <code>str</code> as value.</li> <li>from a <code>bytearray</code>: <code>bp = BinaPy(bytearray(b'my bytearray data'))</code></li> <li>from an <code>int</code> array: bp = <code>BinaPy([109, 121, 32, 105, 110, 116, 32, 97, 114, 114, 97, 121])</code></li> <li>from an <code>int</code>: <code>bp = BinaPy.from_int(82412341)</code>. You may additionally pass <code>size</code>, <code>order</code>, and <code>signed</code> parameters, with the same semantics as <code>int.to_bytes((length, byteorder, signed=False)</code>. You can do the opposite and convert an BinaPy to an int with <code>bp.to_int()</code>.</li> <li>with random data, of arbitrary size: <code>bp = BinaPy.random(32)</code>. The parameter is the size of the generated data, in bytes.</li> <li>from a string containing the binary representation of your data: <code>bp = BinaPy.from_binary_string('101010')</code>. The reverse transformation is available with <code>bp.to_binary_string()</code>.</li> </ul>"},{"location":"usage/#encoding--decoding--transformations","title":"Encoding / Decoding / Transformations","text":"<p>Use the methods <code>encode_to()</code> (or its alias <code>.to()</code>) and <code>decode_from()</code> to transform a BinaPy value into another, using an encoding or transformation scheme. The result value being a BinaPy, you can keep applying those transformations fluently.</p> <p>For example, to generate a random binary data, hash it with SHA256 then Base64-url encode the result:</p> <pre><code>bp = BinaPy.random(128).to(\"sha256\").encode_to(\"b64u\")\nprint(bp)\n# b'QTs64tuMZ-TnyYPhjopIryaFPeF26SKKN4y-su2sBYg'\n</code></pre> <p>To illustrate the <code>.decode_from()</code> method, lets Base64-url decode this value and convert it to hex:</p> <pre><code>print(bp.decode_from(\"b64u\").to(\"hex\"))\n# b'413b3ae2db8c67e4e7c983e18e8a48af26853de176e9228a378cbeb2edac0588'\n</code></pre> <p>A few noteworthy remarks:</p> <ul> <li>some transformations, such as hashes, are irreversible, so they can only be used with the <code>encode_to()</code> method.</li> <li>the verb encode is not really suitable for hashes. That's one of the 2 reasons the <code>.to()</code> alias exists. The other reason is that it's shorter :)</li> <li>there is no <code>from()</code> alias to <code>decode_from()</code>. That's because <code>from</code> is a reversed word in Python, so it cannot be used as a method name. <code>from_()</code> could be used but it makes the code much uglier than <code>decode_from()</code>.</li> </ul>"},{"location":"usage/#converting-from-binary-to-text-or-numeric-data-types","title":"Converting from binary to text or numeric data types","text":"<p><code>BinaPy</code> has a few convenience methods to convert a binary data into:</p> <ul> <li>a string: you can use <code>.decode()</code> as usual, with any Python-supported encoding as parameter. However, very often you will want to have a limited set of characters in the result. You can check this by using <code>.ascii()</code>, <code>.text()</code>, <code>.urlsafe()</code>, <code>.alphanumeric()</code></li> <li>an integer: use <code>.to_int()</code>, with optional parameters <code>byteorder</code> and <code>signed</code> with the same semantics as int.from_bytes.</li> <li>a binary string: use <code>.to_binary_string()</code>.</li> </ul>"},{"location":"usage/#checking-data-contents","title":"Checking data contents","text":"<p>You can check if a BinaPy data conforms with a given extension using the <code>.check(name)</code> method.</p> <pre><code>bp = BinaPy(b\"ThisIsData==\")\nbp.check(\"b64\")\n# True\nbp.check(\"hex\")\n# False\n</code></pre> <p>You can also check a BinaPy against all extensions using <code>.check_all()</code>. For example, any random 20 bytes could be the result from a SHA1 hash:</p> <pre><code>bp = BinaPy.random(20)\nbp.check_all()\n# ['sha1']\n</code></pre> <p>While a given string with only hex characters could be a hexadecimal string, it could also be the result of a base64 or a base64url encoding.</p> <pre><code>bp = BinaPy(\"abcdef1234567890\")\nbp.check_all()\n# ['b64', 'b64u', 'hex']\n# ['b64', 'b64u', 'hex']\n</code></pre>"},{"location":"usage/#loading-and-dumping","title":"Loading and dumping","text":"<p>Dumping and encoding data can be done this way:</p> <pre><code>BinaPy.serialize_to(\"json\", {\"foo\": \"bar\"}).to(\"b64u\")\n# b'ewoiZm9vIjogImJhciIKfQ'\n</code></pre> <p>Loading serialized and encoded data can be done this way:</p> <pre><code>BinaPy(b\"ewoiZm9vIjogImJhciIKfQ\").decode_from(\"b64u\").parse_from(\"json\")\n# {'foo': 'bar'}\n</code></pre>"},{"location":"usage/#extend","title":"extend","text":"<p>You can implement additional methods for BinaPy. Methods can implement one or several of the following features:</p> <ul> <li>an encoder: this will transform/encode the current BinaPy into another BinaPy. E.g., a base64 encoder will transform arbitrary binary data into a base64 encoded string.</li> <li>a decoder: this will transform an encoded data back into its initial data. E.g., a base64 decoder.</li> <li>a checker: this will check if a given data conforms to a given format. Which means that this data could have been produced with a matching encoder and can probably be decoded with the matching decoder, if available.</li> <li>a parser: this will parse the current BinaPy data into another format. E.g., a JSON parser</li> <li>a serializer: this will serialize data from another format into a BinaPy. E.g, a JSON dumper</li> </ul> <p>Note that the terms encode and decode are quite loose, because they are applied to compression, hashing and other transformations that produce or consume binary data.</p> <p>To implement such a method, use one of the <code>binapy_&lt;feature&gt;()</code> decorators. Each decorator takes the name of the extension as parameter.</p> <pre><code>from binapy import binapy_encoder\n\n\n@binapy_encoder(\"myformat\")\ndef encode_myformat(bp) -&gt; bytes:\n    # apply your transformation\n    return my_transformation(bp)\n</code></pre> <p>This <code>binapy_encoder()</code> decorator will:</p> <ul> <li>register this method in BinaPy extension registry, so that it can be called with <code>BinaPy(my_data).encode_to('myformat')</code>.</li> <li>if that methods returns a <code>bytes</code> or a <code>bytesarray</code>, make sure that it returns a <code>BinaPy</code> instead, to make sure it is fluent.</li> </ul> <p>Some formats such as base64 can have all 3 methods implemented. Others such as hashes only have an encoder and a checker method:</p> <ul> <li>the encoder does the actual hashing (that is, by definition, irreversible)</li> <li>the checker method checks that a given data is the appropriate length for the given hash</li> </ul> <p>Finally, some formats like gzip do not have a checker method, because trying to decode the data is faster and easier than validating it statically. BinaPy will then try the decode method instead and see if it raises an Exception.</p>"}]}