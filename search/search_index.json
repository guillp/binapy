{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"home","text":""},{"location":"#binapy","title":"BinaPy","text":"<p>BinaPy is a module that makes Binary Data manipulation simpler and easier than what is offered in the Python standard library.</p> <p>With BinaPy, encoding or decoding data in a number of formats (base64, base64url, hex, url-encoding, etc.), compressing or decompressing (gzip), hashing (SHA1, SHA256, MD5, etc., with or without salt), is all a single method call away! And you can extend it with new formats and features.</p> <pre><code>from binapy import BinaPy\n\nbp = BinaPy(\"Hello, World!\").to(\"deflate\").to(\"b64u\")\nprint(bp)\n# b'80jNycnXUQjPL8pJUQQA'\nbp.decode_from(\"b64u\").decode_from(\"deflate\").decode()\n# \"Hello, World!\"\nisinstance(bp, bytes)\n# True\n</code></pre> <ul> <li>Free software: MIT</li> <li>Documentation: https://guillp.github.io/binapy/</li> </ul>"},{"location":"#features","title":"Features","text":"<ul> <li>Fluent interface, based on a <code>bytes</code> subclass</li> <li>Provides a convenient interface over <code>hashlib</code>, <code>base64</code>, <code>zlib</code>, <code>urllib.parse</code>, <code>json</code> and more</li> <li>Easy to extend with new formats</li> </ul>"},{"location":"#todo","title":"TODO","text":"<ul> <li>add more parsing formats like YAML, CBOR, etc.</li> <li>optionally use faster third-party modules when available</li> </ul>"},{"location":"api/","title":"API","text":""},{"location":"api/#binapy","title":"<code>binapy</code>","text":"<p>Top-level package for BinaPy.</p>"},{"location":"api/#binapy.BinaPy","title":"<code>BinaPy</code>","text":"<p>         Bases: <code>bytes</code></p> <p>A helper class for binary data manipulation.</p> <p>This subclass of <code>bytes</code> exposes various binary data manipulation methods. Since this is a <code>bytes</code> subclass, you can use instances of <code>BinaPy</code> anywhere you can use <code>bytes</code>. BinaPy allows (re)encoding of data using <code>encode_to(&lt;format&gt;)</code>, decoding using <code>decode_from(&lt;format&gt;)</code>, parsing using <code>parse_from(&lt;format&gt;)</code>, and serialisation using <code>serialize_to(&lt;format&gt;)</code>.</p> <p>Actual transformations into formats such as Base64, JSON, etc. are implemented using Extensions. Those extensions are registered using the decorators <code>binapy_encoder</code>, <code>binapy_decoder</code>, <code>binapy_checker</code>, <code>binapy_serializer</code>, and <code>binapy_parser</code>.</p> Source code in <code>binapy/binapy.py</code> <pre><code>class BinaPy(bytes):\n\"\"\"A helper class for binary data manipulation.\n\n    This subclass of `bytes` exposes various binary data manipulation methods. Since this is\n    a `bytes` subclass, you can use instances of `BinaPy` anywhere you can use `bytes`. BinaPy\n    allows (re)encoding of data using `encode_to(&lt;format&gt;)`, decoding using\n    `decode_from(&lt;format&gt;)`, parsing using `parse_from(&lt;format&gt;)`, and serialisation using\n    `serialize_to(&lt;format&gt;)`.\n\n    Actual transformations into formats such as Base64, JSON, etc. are implemented using\n    Extensions. Those extensions are registered using the decorators `binapy_encoder`,\n    `binapy_decoder`, `binapy_checker`, `binapy_serializer`, and `binapy_parser`.\n    \"\"\"\n\n    def __new__(\n        cls,\n        value: Union[bytes, str, int, SupportsBytes] = b\"\",\n        encoding: str = \"utf-8\",\n        errors: str = \"strict\",\n    ) -&gt; \"BinaPy\":\n\"\"\"Override base method to accept a string with a default encoding of \"utf-8\".\n\n        See Also:\n            [`bytes` constructor](https://docs.python.org/3/library/stdtypes.html#bytes) and\n            [`str.encode()`](https://docs.python.org/3/library/stdtypes.html#str.encode)\n\n        Args:\n            value: a `bytes` or a `str`\n            encoding: if value is a `str`, specifies the encoding to use to encode this str to bytes\n            errors: 'strict', 'ignore', 'replace', 'xmlcharrefreplace', or 'backslashreplace'\n        \"\"\"\n        if isinstance(value, str):\n            obj = bytes.__new__(cls, value, encoding=encoding, errors=errors)\n        else:\n            obj = bytes.__new__(cls, value)\n        return obj\n\n    @classmethod\n    def from_int(\n        cls,\n        i: int,\n        length: Optional[int] = None,\n        byteorder: Literal[\"little\", \"big\"] = \"big\",\n        signed: bool = False,\n    ) -&gt; \"BinaPy\":\n\"\"\"Convert an `int` to a `BinaPy`.\n\n        This is a wrapper around [int.to_bytes()](https://docs.python.org/3/library/stdtypes.html#int.to_bytes) and\n        takes the same parameters.\n\n        Args:\n            i: the integer to convert to BinaPy\n            length: the length of the integer, in bytes. If omitted, takes the minimal length that fits the given integer.\n            byteorder: \"little\" or \"big\" (defaults to \"big\")\n            signed: determines whether two\u2019s complement is used to represent the integer.\n\n        Returns:\n            a BinaPy with the binary representation of the given integer\n        \"\"\"\n        if length is None:\n            length = (i.bit_length() + 7) // 8\n\n        data = i.to_bytes(length, byteorder, signed=signed)\n        return cls(data)\n\n    def ascii(self) -&gt; str:\n\"\"\"Decode this BinaPy to a str.\n\n        This makes sure that only ascii characters are part of the result.\n\n        Returns:\n            a str with only ASCII chars\n        \"\"\"\n        return self.decode(\"ascii\")\n\n    def re_match(self, pattern: str, encoding: str = \"ascii\") -&gt; str:\n\"\"\"Decode this binary value to a string, then match it to a regex.\n\n        Decoding is done using the encoding defined in `encoding` (default to \"ascii\").\n        The decoded value is then matched with the regular expression `pattern`.\n\n        If the match is successful, return the decoded string. Raise a `ValueError` otherwise.\n\n        Args:\n            pattern: the regular expression pattern to match\n            encoding: the encoding to use to decode the binary value to a string\n\n        Returns:\n            the decoded, matching `str`\n\n        Raises:\n            ValueError: if the decoded str doesn't match `pattern`\n        \"\"\"\n        res = self.decode(encoding)\n        if re.match(pattern, res):\n            return res\n        raise ValueError(f\"This value doesn't match pattern {pattern}\")\n\n    def text(self, encoding: str = \"ascii\") -&gt; str:\nr\"\"\"Decode this BinaPy to a str, and check that the result is printable.\n\n        Printable characters are characters from the range `[a-zA-Z0-9!\"#$%&amp;\\'()*+,-./:;&lt;=&gt;?@[\\\\]^_`{|}~ ]`.\n\n        Args:\n            encoding: the encoding to use to decode the binary data\n\n        Returns:\n            the decoded text\n        \"\"\"\n        return self.re_match(\n            r'^[a-zA-Z0-9!\"#$%&amp;\\'()*+,-./:;&lt;=&gt;?@[\\\\]^_`{|}~ ]*$', encoding\n        )\n\n    def urlsafe(self) -&gt; str:\nr\"\"\"Convert this BinaPy to a str, and check that it contains only url-safe characters.\n\n        Url-safe characters are `[A-Za-z0-9_.\\\\-~]`.\n\n        Returns:\n            a str with only URL-safe chars\n        \"\"\"\n        return self.re_match(r\"^[A-Za-z0-9_.\\-~]$\")\n\n    def alphanumeric(self) -&gt; str:\n\"\"\"Check that this BinaPy contains only alphanumeric characters.\n\n        Returns:\n            a str with only alphanumeric chars\n        \"\"\"\n        return self.re_match(r\"^[a-zA-Z]$\")\n\n    def to_int(\n        self, byteorder: Literal[\"little\", \"big\"] = \"big\", signed: bool = False\n    ) -&gt; int:\n\"\"\"Convert this BinaPy to an `int`.\n\n        This is a wrapper around\n        [int.from_bytes()](https://docs.python.org/3/library/stdtypes.html#int.from_bytes) and takes\n        the same parameters.\n\n        Args:\n            byteorder: \"little\" or \"big\" (defaults to \"big\")\n            signed: determines whether two\u2019s complement is used to represent the integer. Default to False.\n\n        Returns:\n            an integer based on this BinaPy binary value\n        \"\"\"\n        return int.from_bytes(self, byteorder, signed=signed)\n\n    @classmethod\n    def from_binary_string(\n        cls, s: str, byteorder: Literal[\"little\", \"big\"] = \"big\", signed: bool = False\n    ) -&gt; \"BinaPy\":\n\"\"\"Initialize a BinaPy based on a binary string (containing only 0 and 1).\n\n        The string may contain spaces or tabs characters which will be ignored.\n\n        Args:\n            s: a binary string\n            byteorder: byte order to use\n            signed: True if 2 complement is used to represent negative values\n\n        Returns:\n            a BinaPy\n        \"\"\"\n        s = s.replace(\" \", \"\").replace(\"\\t\", \"\")\n        return cls(\n            int(s, 2).to_bytes((len(s) + 7) // 8, byteorder=byteorder, signed=signed)\n        )\n\n    def to_binary_string(\n        self,\n        byteorder: Literal[\"little\", \"big\"] = \"big\",\n        signed: bool = False,\n        pad: bool = True,\n    ) -&gt; str:\n\"\"\"Return a string containing this BinaPy value in binary representation.\n\n        Args:\n            byteorder: byte order to use\n            signed: `True` if 2 complement is used to represent negative values\n            pad: if `True`, left pad the result with 0 to make length a multiple of 8\n\n        Returns:\n            a string with containing only 0 and 1\n        \"\"\"\n        binary = format(self.to_int(byteorder, signed), \"b\")\n        if pad and len(binary) % 8:\n            d = len(binary) // 8\n            return binary.rjust(8 * d + 8, \"0\")\n        return binary\n\n    @classmethod\n    def random(cls, length: int) -&gt; \"BinaPy\":\n\"\"\"Return a BinaPy containing `length` random bytes.\n\n        Args:\n            length: number of bytes to generate\n\n        Returns:\n            a BinaPy with randomly generated data\n        \"\"\"\n        return cls(secrets.token_bytes(length))\n\n    @classmethod\n    def random_bits(cls, length: int) -&gt; \"BinaPy\":\n\"\"\"Return a BinaPy containing `length` random bits. Same as random(length//8).\n\n        Length must be a multiple of 8.\n\n        Args:\n            length: number of bits to randomly generate\n\n        Returns:\n            a BinaPy with randomly generated data\n        \"\"\"\n        return cls(secrets.token_bytes(length // 8))\n\n    @overload\n    def __getitem__(self, index: SupportsIndex) -&gt; int:  # noqa: D105\n        ...  # pragma: no cover\n\n    @overload\n    def __getitem__(self, slice: slice) -&gt; \"BinaPy\":  # noqa: D105\n        ...  # pragma: no cover\n\n    def __getitem__(self, slice: Union[slice, SupportsIndex]) -&gt; \"Union[int, BinaPy]\":\n\"\"\"Override the base method so that slicing returns a BinaPy instead of just bytes.\n\n        Args:\n            slice: a slice or index\n\n        Returns:\n            A BinaPy\n        \"\"\"\n        if isinstance(slice, int):\n            return super().__getitem__(slice)\n        return self.__class__(super().__getitem__(slice))\n\n    def char_at(self, index: int) -&gt; str:\n\"\"\"Return the character at the given index.\n\n        Slicing a standard bytes returns an int. Sometimes what you really want is a single char string.\n\n        Args:\n            index:\n\n        Returns:\n            the single character at the given index\n        \"\"\"\n        return chr(self[index])\n\n    def __add__(\n        self,\n        other: Any,\n    ) -&gt; \"BinaPy\":\n\"\"\"Override base method so that addition returns a BinaPy instead of bytes.\n\n        Args:\n            other: bytes or BinaPy to add\n\n        Returns:\n            a BinaPy\n        \"\"\"\n        return self.__class__(super().__add__(other))\n\n    def __radd__(self, other: bytes) -&gt; \"BinaPy\":\n\"\"\"Override base method so that right addition returns a BinaPy instead of bytes.\n\n        Args:\n            other: bytes or BinaPy to radd\n\n        Returns:\n            a BinaPy\n        \"\"\"\n        return self.__class__(other.__add__(self))\n\n    def split(self, sep: Optional[bytes] = None, maxsplit: int = -1) -&gt; \"List[BinaPy]\":  # type: ignore[override] #noqa: D402\n\"\"\"Override base method so that split() returns a BinaPy instead of bytes.\n\n        Args:\n            sep: a separator\n            maxsplit: the maximum number of splits\n\n        Returns:\n            a BinaPy\n        \"\"\"\n        return [self.__class__(b) for b in super().split(sep, maxsplit)]\n\n    def cut_at(self, *pos: int) -&gt; \"List[BinaPy]\":\n\"\"\"Cut this BinaPy at one or more integer positions.\n\n        Args:\n            *pos: indexes where to cut the BinaPy\n\n        Returns:\n            `len(pos) + 1` parts, instances of BinaPy\n        \"\"\"\n        spos = sorted(pos)\n        return [\n            self.__class__(self[start:end])\n            for start, end in zip([0] + spos, spos + [len(self)])\n        ]\n\n    extensions: Dict[str, Dict[str, Callable[..., Any]]] = {}\n\"\"\"Extension registry.\"\"\"\n\n    @classmethod\n    def _get_extension_methods(cls, name: str) -&gt; Dict[str, Callable[..., Any]]:\n        extension = cls.extensions.get(name)\n        if extension is None:\n            raise NotImplementedError(f\"Extension {name} not found\")\n        return extension\n\n    @classmethod\n    def _get_checker(cls, extension_name: str) -&gt; Callable[..., bool]:\n        extension_methods = cls._get_extension_methods(extension_name)\n        method = extension_methods.get(\"check\")\n        if method is None:\n            raise NotImplementedError(\n                f\"Extension {extension_name} doesn't have a checker method\"\n            )\n        return method\n\n    @classmethod\n    def _get_decoder(cls, extension_name: str) -&gt; \"Callable[..., BinaPy]\":\n        extension_methods = cls._get_extension_methods(extension_name)\n        method = extension_methods.get(\"decode\")\n        if method is None:\n            raise NotImplementedError(\n                f\"Extension {extension_name} doesn't have a decode method\"\n            )\n        return method\n\n    @classmethod\n    def _get_encoder(cls, extension_name: str) -&gt; \"Callable[..., BinaPy]\":\n        extension_methods = cls._get_extension_methods(extension_name)\n        method = extension_methods.get(\"encode\")\n        if method is None:\n            raise NotImplementedError(\n                f\"Extension {extension_name} doesn't have an encode method\"\n            )\n        return method\n\n    @classmethod\n    def _get_parser(cls, extension_name: str) -&gt; Callable[..., Any]:\n        extension_methods = cls._get_extension_methods(extension_name)\n        method = extension_methods.get(\"parse\")\n        if method is None:\n            raise NotImplementedError(\n                f\"Extension {extension_name} doesn't have a parse method\"\n            )\n        return method\n\n    @classmethod\n    def _get_serializer(cls, extension_name: str) -&gt; \"Callable[..., BinaPy]\":\n        extension_methods = cls._get_extension_methods(extension_name)\n        method = extension_methods.get(\"serialize\")\n        if method is None:\n            raise NotImplementedError(\n                f\"Extension {extension_name} doesn't have a serialize method\"\n            )\n        return method\n\n    def encode_to(self, name: str, *args: Any, **kwargs: Any) -&gt; \"BinaPy\":\n\"\"\"Encode data from this BinaPy according to the format `name`.\n\n        Args:\n            name: format to use\n            *args: additional position parameters for the extension encoder method\n            **kwargs: additional keyword parameters for the extension encoder method\n\n        Returns:\n            the resulting data\n        \"\"\"\n        encoder = self._get_encoder(name)\n\n        return encoder(self, *args, **kwargs)\n\n    def to(self, name: str, *args: Any, **kwargs: Any) -&gt; \"BinaPy\":  # noqa: D402\n\"\"\"Alias for `encode_to()`.\n\n        Args:\n            name: same as `encode_to()`\n            *args:  same as `encode_to()`\n            **kwargs:  same as `encode_to()`\n\n        Returns:\n            same as `encode_to()`\n        \"\"\"\n        return self.encode_to(name, *args, **kwargs)\n\n    def decode_from(self, name: str, *args: Any, **kwargs: Any) -&gt; \"BinaPy\":\n\"\"\"Decode data from this BinaPy according to the format `name`.\n\n        Args:\n            name: format name to use\n            *args: additional position parameters for the extension decoder method\n            **kwargs: additional keyword parameters for the extension decoder method\n\n        Returns:\n            the resulting data\n        \"\"\"\n        decoder = self._get_decoder(name)\n\n        return decoder(self, *args, **kwargs)\n\n    def check(\n        self, name: str, decode: bool = False, raise_on_error: bool = False\n    ) -&gt; bool:\n\"\"\"Check that this BinaPy conforms to a given format extension.\n\n        Args:\n            name: the name of the extension to check\n            decode: if `True`, and the given extension doesn't have a checker method, try to decode this BinaPy using the decoder method to check if that works.\n            raise_on_error: if True, Exceptions from the checker method, if any, will be raised instead of returning `False`.\n\n        Returns:\n            a boolean, that is True if this BinaPy conforms to the given extension format, False otherwise.\n        \"\"\"\n        # raises an exception in case the extension doesn't exist\n        self._get_extension_methods(name)\n\n        try:\n            checker = self._get_checker(name)\n            try:\n                return checker(self)\n            except InvalidExtensionMethod as exc:\n                raise exc\n            except Exception as exc:\n                if raise_on_error:\n                    raise exc from exc\n                return False\n        except NotImplementedError:\n            try:\n                # if checker is not implemented and decode is True, try to decode instead\n                if decode:\n                    decoder = self._get_decoder(name)\n                    try:\n                        decoder(self)\n                        return True\n                    except Exception as exc:\n                        if raise_on_error:\n                            raise exc from exc\n                        return False\n            except NotImplementedError:\n                return False\n        return False\n\n    def check_all(self, decode: bool = False) -&gt; List[str]:\n\"\"\"Check if this BinaPy conforms to any of the registered format extensions.\n\n        Returns:\n             a list of format extensions that this BinaPy can be decoded from.\n\n        Args:\n            decode: if `True`, for extensions that don't have a checker method,\n                try to decode this BinaPy using the decoder method to check if that works.\n        \"\"\"\n\n        def get_results() -&gt; Iterator[str]:\n            for name in self.extensions:\n                success = self.check(name, decode=decode)\n                if success is True:\n                    yield name\n\n        return list(get_results())\n\n    def parse_from(self, name: str, *args: Any, **kwargs: Any) -&gt; Any:\n\"\"\"Parse data from this BinaPy, based on a given format extension.\n\n        Args:\n            name: name of the extension to use\n            *args: additional position parameters for the extension decoder method\n            **kwargs: additional keyword parameters for the extension decoder method\n\n        Returns:\n            the result from parsing this BinaPy\n        \"\"\"\n        parser = self._get_parser(name)\n\n        return parser(self, *args, **kwargs)\n\n    @classmethod\n    def serialize_to(cls, name: str, *args: Any, **kwargs: Any) -&gt; \"BinaPy\":\n\"\"\"Serialize (dump) data to a BinaPy, based on a given extension format.\n\n        Args:\n            name: name of the extension to use\n            *args: additional position parameters for the extension decoder method (which includes the data to serialize)\n            **kwargs: additional keyword parameters for the extension decoder method\n\n        Returns:\n            a BinaPy, resulting from serialization of the data\n        \"\"\"\n        serializer = cls._get_serializer(name)\n\n        return serializer(*args, **kwargs)\n\n    @classmethod\n    def register_extension(\n        cls, name: str, feature: str, func: Callable[..., Any]\n    ) -&gt; None:\n\"\"\"Register a new feature for the given extension name.\n\n        Args:\n            name: the extension name\n            feature: name of the feature to register (\"encode\", \"decode\", etc.)\n            func: the method implementing the feature\n        \"\"\"\n        ext_dict = cls.extensions.setdefault(name, {})\n        ext_dict[feature] = func\n</code></pre>"},{"location":"api/#binapy.binapy.BinaPy.extensions","title":"<code>extensions: Dict[str, Dict[str, Callable[..., Any]]] = {}</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Extension registry.</p>"},{"location":"api/#binapy.binapy.BinaPy.from_int","title":"<code>from_int(i, length=None, byteorder='big', signed=False)</code>  <code>classmethod</code>","text":"<p>Convert an <code>int</code> to a <code>BinaPy</code>.</p> <p>This is a wrapper around int.to_bytes() and takes the same parameters.</p> <p>Parameters:</p> Name Type Description Default <code>i</code> <code>int</code> <p>the integer to convert to BinaPy</p> required <code>length</code> <code>Optional[int]</code> <p>the length of the integer, in bytes. If omitted, takes the minimal length that fits the given integer.</p> <code>None</code> <code>byteorder</code> <code>Literal['little', 'big']</code> <p>\"little\" or \"big\" (defaults to \"big\")</p> <code>'big'</code> <code>signed</code> <code>bool</code> <p>determines whether two\u2019s complement is used to represent the integer.</p> <code>False</code> <p>Returns:</p> Type Description <code>BinaPy</code> <p>a BinaPy with the binary representation of the given integer</p> Source code in <code>binapy/binapy.py</code> <pre><code>@classmethod\ndef from_int(\n    cls,\n    i: int,\n    length: Optional[int] = None,\n    byteorder: Literal[\"little\", \"big\"] = \"big\",\n    signed: bool = False,\n) -&gt; \"BinaPy\":\n\"\"\"Convert an `int` to a `BinaPy`.\n\n    This is a wrapper around [int.to_bytes()](https://docs.python.org/3/library/stdtypes.html#int.to_bytes) and\n    takes the same parameters.\n\n    Args:\n        i: the integer to convert to BinaPy\n        length: the length of the integer, in bytes. If omitted, takes the minimal length that fits the given integer.\n        byteorder: \"little\" or \"big\" (defaults to \"big\")\n        signed: determines whether two\u2019s complement is used to represent the integer.\n\n    Returns:\n        a BinaPy with the binary representation of the given integer\n    \"\"\"\n    if length is None:\n        length = (i.bit_length() + 7) // 8\n\n    data = i.to_bytes(length, byteorder, signed=signed)\n    return cls(data)\n</code></pre>"},{"location":"api/#binapy.binapy.BinaPy.ascii","title":"<code>ascii()</code>","text":"<p>Decode this BinaPy to a str.</p> <p>This makes sure that only ascii characters are part of the result.</p> <p>Returns:</p> Type Description <code>str</code> <p>a str with only ASCII chars</p> Source code in <code>binapy/binapy.py</code> <pre><code>def ascii(self) -&gt; str:\n\"\"\"Decode this BinaPy to a str.\n\n    This makes sure that only ascii characters are part of the result.\n\n    Returns:\n        a str with only ASCII chars\n    \"\"\"\n    return self.decode(\"ascii\")\n</code></pre>"},{"location":"api/#binapy.binapy.BinaPy.re_match","title":"<code>re_match(pattern, encoding='ascii')</code>","text":"<p>Decode this binary value to a string, then match it to a regex.</p> <p>Decoding is done using the encoding defined in <code>encoding</code> (default to \"ascii\"). The decoded value is then matched with the regular expression <code>pattern</code>.</p> <p>If the match is successful, return the decoded string. Raise a <code>ValueError</code> otherwise.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>str</code> <p>the regular expression pattern to match</p> required <code>encoding</code> <code>str</code> <p>the encoding to use to decode the binary value to a string</p> <code>'ascii'</code> <p>Returns:</p> Type Description <code>str</code> <p>the decoded, matching <code>str</code></p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if the decoded str doesn't match <code>pattern</code></p> Source code in <code>binapy/binapy.py</code> <pre><code>def re_match(self, pattern: str, encoding: str = \"ascii\") -&gt; str:\n\"\"\"Decode this binary value to a string, then match it to a regex.\n\n    Decoding is done using the encoding defined in `encoding` (default to \"ascii\").\n    The decoded value is then matched with the regular expression `pattern`.\n\n    If the match is successful, return the decoded string. Raise a `ValueError` otherwise.\n\n    Args:\n        pattern: the regular expression pattern to match\n        encoding: the encoding to use to decode the binary value to a string\n\n    Returns:\n        the decoded, matching `str`\n\n    Raises:\n        ValueError: if the decoded str doesn't match `pattern`\n    \"\"\"\n    res = self.decode(encoding)\n    if re.match(pattern, res):\n        return res\n    raise ValueError(f\"This value doesn't match pattern {pattern}\")\n</code></pre>"},{"location":"api/#binapy.binapy.BinaPy.text","title":"<code>text(encoding='ascii')</code>","text":"<p>Decode this BinaPy to a str, and check that the result is printable.</p> <p>Printable characters are characters from the range <code>[a-zA-Z0-9!\"#$%&amp;\\'()*+,-./:;&lt;=&gt;?@[\\\\]^_</code>~ ]`.</p> <p>Parameters:</p> Name Type Description Default <code>encoding</code> <code>str</code> <p>the encoding to use to decode the binary data</p> <code>'ascii'</code> <p>Returns:</p> Type Description <code>str</code> <p>the decoded text</p> Source code in <code>binapy/binapy.py</code> <pre><code>def text(self, encoding: str = \"ascii\") -&gt; str:\nr\"\"\"Decode this BinaPy to a str, and check that the result is printable.\n\n    Printable characters are characters from the range `[a-zA-Z0-9!\"#$%&amp;\\'()*+,-./:;&lt;=&gt;?@[\\\\]^_`{|}~ ]`.\n\n    Args:\n        encoding: the encoding to use to decode the binary data\n\n    Returns:\n        the decoded text\n    \"\"\"\n    return self.re_match(\n        r'^[a-zA-Z0-9!\"#$%&amp;\\'()*+,-./:;&lt;=&gt;?@[\\\\]^_`{|}~ ]*$', encoding\n    )\n</code></pre>"},{"location":"api/#binapy.binapy.BinaPy.urlsafe","title":"<code>urlsafe()</code>","text":"<p>Convert this BinaPy to a str, and check that it contains only url-safe characters.</p> <p>Url-safe characters are <code>[A-Za-z0-9_.\\\\-~]</code>.</p> <p>Returns:</p> Type Description <code>str</code> <p>a str with only URL-safe chars</p> Source code in <code>binapy/binapy.py</code> <pre><code>def urlsafe(self) -&gt; str:\nr\"\"\"Convert this BinaPy to a str, and check that it contains only url-safe characters.\n\n    Url-safe characters are `[A-Za-z0-9_.\\\\-~]`.\n\n    Returns:\n        a str with only URL-safe chars\n    \"\"\"\n    return self.re_match(r\"^[A-Za-z0-9_.\\-~]$\")\n</code></pre>"},{"location":"api/#binapy.binapy.BinaPy.alphanumeric","title":"<code>alphanumeric()</code>","text":"<p>Check that this BinaPy contains only alphanumeric characters.</p> <p>Returns:</p> Type Description <code>str</code> <p>a str with only alphanumeric chars</p> Source code in <code>binapy/binapy.py</code> <pre><code>def alphanumeric(self) -&gt; str:\n\"\"\"Check that this BinaPy contains only alphanumeric characters.\n\n    Returns:\n        a str with only alphanumeric chars\n    \"\"\"\n    return self.re_match(r\"^[a-zA-Z]$\")\n</code></pre>"},{"location":"api/#binapy.binapy.BinaPy.to_int","title":"<code>to_int(byteorder='big', signed=False)</code>","text":"<p>Convert this BinaPy to an <code>int</code>.</p> <p>This is a wrapper around int.from_bytes() and takes the same parameters.</p> <p>Parameters:</p> Name Type Description Default <code>byteorder</code> <code>Literal['little', 'big']</code> <p>\"little\" or \"big\" (defaults to \"big\")</p> <code>'big'</code> <code>signed</code> <code>bool</code> <p>determines whether two\u2019s complement is used to represent the integer. Default to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>int</code> <p>an integer based on this BinaPy binary value</p> Source code in <code>binapy/binapy.py</code> <pre><code>def to_int(\n    self, byteorder: Literal[\"little\", \"big\"] = \"big\", signed: bool = False\n) -&gt; int:\n\"\"\"Convert this BinaPy to an `int`.\n\n    This is a wrapper around\n    [int.from_bytes()](https://docs.python.org/3/library/stdtypes.html#int.from_bytes) and takes\n    the same parameters.\n\n    Args:\n        byteorder: \"little\" or \"big\" (defaults to \"big\")\n        signed: determines whether two\u2019s complement is used to represent the integer. Default to False.\n\n    Returns:\n        an integer based on this BinaPy binary value\n    \"\"\"\n    return int.from_bytes(self, byteorder, signed=signed)\n</code></pre>"},{"location":"api/#binapy.binapy.BinaPy.from_binary_string","title":"<code>from_binary_string(s, byteorder='big', signed=False)</code>  <code>classmethod</code>","text":"<p>Initialize a BinaPy based on a binary string (containing only 0 and 1).</p> <p>The string may contain spaces or tabs characters which will be ignored.</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>str</code> <p>a binary string</p> required <code>byteorder</code> <code>Literal['little', 'big']</code> <p>byte order to use</p> <code>'big'</code> <code>signed</code> <code>bool</code> <p>True if 2 complement is used to represent negative values</p> <code>False</code> <p>Returns:</p> Type Description <code>BinaPy</code> <p>a BinaPy</p> Source code in <code>binapy/binapy.py</code> <pre><code>@classmethod\ndef from_binary_string(\n    cls, s: str, byteorder: Literal[\"little\", \"big\"] = \"big\", signed: bool = False\n) -&gt; \"BinaPy\":\n\"\"\"Initialize a BinaPy based on a binary string (containing only 0 and 1).\n\n    The string may contain spaces or tabs characters which will be ignored.\n\n    Args:\n        s: a binary string\n        byteorder: byte order to use\n        signed: True if 2 complement is used to represent negative values\n\n    Returns:\n        a BinaPy\n    \"\"\"\n    s = s.replace(\" \", \"\").replace(\"\\t\", \"\")\n    return cls(\n        int(s, 2).to_bytes((len(s) + 7) // 8, byteorder=byteorder, signed=signed)\n    )\n</code></pre>"},{"location":"api/#binapy.binapy.BinaPy.to_binary_string","title":"<code>to_binary_string(byteorder='big', signed=False, pad=True)</code>","text":"<p>Return a string containing this BinaPy value in binary representation.</p> <p>Parameters:</p> Name Type Description Default <code>byteorder</code> <code>Literal['little', 'big']</code> <p>byte order to use</p> <code>'big'</code> <code>signed</code> <code>bool</code> <p><code>True</code> if 2 complement is used to represent negative values</p> <code>False</code> <code>pad</code> <code>bool</code> <p>if <code>True</code>, left pad the result with 0 to make length a multiple of 8</p> <code>True</code> <p>Returns:</p> Type Description <code>str</code> <p>a string with containing only 0 and 1</p> Source code in <code>binapy/binapy.py</code> <pre><code>def to_binary_string(\n    self,\n    byteorder: Literal[\"little\", \"big\"] = \"big\",\n    signed: bool = False,\n    pad: bool = True,\n) -&gt; str:\n\"\"\"Return a string containing this BinaPy value in binary representation.\n\n    Args:\n        byteorder: byte order to use\n        signed: `True` if 2 complement is used to represent negative values\n        pad: if `True`, left pad the result with 0 to make length a multiple of 8\n\n    Returns:\n        a string with containing only 0 and 1\n    \"\"\"\n    binary = format(self.to_int(byteorder, signed), \"b\")\n    if pad and len(binary) % 8:\n        d = len(binary) // 8\n        return binary.rjust(8 * d + 8, \"0\")\n    return binary\n</code></pre>"},{"location":"api/#binapy.binapy.BinaPy.random","title":"<code>random(length)</code>  <code>classmethod</code>","text":"<p>Return a BinaPy containing <code>length</code> random bytes.</p> <p>Parameters:</p> Name Type Description Default <code>length</code> <code>int</code> <p>number of bytes to generate</p> required <p>Returns:</p> Type Description <code>BinaPy</code> <p>a BinaPy with randomly generated data</p> Source code in <code>binapy/binapy.py</code> <pre><code>@classmethod\ndef random(cls, length: int) -&gt; \"BinaPy\":\n\"\"\"Return a BinaPy containing `length` random bytes.\n\n    Args:\n        length: number of bytes to generate\n\n    Returns:\n        a BinaPy with randomly generated data\n    \"\"\"\n    return cls(secrets.token_bytes(length))\n</code></pre>"},{"location":"api/#binapy.binapy.BinaPy.random_bits","title":"<code>random_bits(length)</code>  <code>classmethod</code>","text":"<p>Return a BinaPy containing <code>length</code> random bits. Same as random(length//8).</p> <p>Length must be a multiple of 8.</p> <p>Parameters:</p> Name Type Description Default <code>length</code> <code>int</code> <p>number of bits to randomly generate</p> required <p>Returns:</p> Type Description <code>BinaPy</code> <p>a BinaPy with randomly generated data</p> Source code in <code>binapy/binapy.py</code> <pre><code>@classmethod\ndef random_bits(cls, length: int) -&gt; \"BinaPy\":\n\"\"\"Return a BinaPy containing `length` random bits. Same as random(length//8).\n\n    Length must be a multiple of 8.\n\n    Args:\n        length: number of bits to randomly generate\n\n    Returns:\n        a BinaPy with randomly generated data\n    \"\"\"\n    return cls(secrets.token_bytes(length // 8))\n</code></pre>"},{"location":"api/#binapy.binapy.BinaPy.char_at","title":"<code>char_at(index)</code>","text":"<p>Return the character at the given index.</p> <p>Slicing a standard bytes returns an int. Sometimes what you really want is a single char string.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> required <p>Returns:</p> Type Description <code>str</code> <p>the single character at the given index</p> Source code in <code>binapy/binapy.py</code> <pre><code>def char_at(self, index: int) -&gt; str:\n\"\"\"Return the character at the given index.\n\n    Slicing a standard bytes returns an int. Sometimes what you really want is a single char string.\n\n    Args:\n        index:\n\n    Returns:\n        the single character at the given index\n    \"\"\"\n    return chr(self[index])\n</code></pre>"},{"location":"api/#binapy.binapy.BinaPy.split","title":"<code>split(sep=None, maxsplit=-1)</code>","text":"<p>Override base method so that split() returns a BinaPy instead of bytes.</p> <p>Parameters:</p> Name Type Description Default <code>sep</code> <code>Optional[bytes]</code> <p>a separator</p> <code>None</code> <code>maxsplit</code> <code>int</code> <p>the maximum number of splits</p> <code>-1</code> <p>Returns:</p> Type Description <code>List[BinaPy]</code> <p>a BinaPy</p> Source code in <code>binapy/binapy.py</code> <pre><code>def split(self, sep: Optional[bytes] = None, maxsplit: int = -1) -&gt; \"List[BinaPy]\":  # type: ignore[override] #noqa: D402\n\"\"\"Override base method so that split() returns a BinaPy instead of bytes.\n\n    Args:\n        sep: a separator\n        maxsplit: the maximum number of splits\n\n    Returns:\n        a BinaPy\n    \"\"\"\n    return [self.__class__(b) for b in super().split(sep, maxsplit)]\n</code></pre>"},{"location":"api/#binapy.binapy.BinaPy.cut_at","title":"<code>cut_at(*pos)</code>","text":"<p>Cut this BinaPy at one or more integer positions.</p> <p>Parameters:</p> Name Type Description Default <code>*pos</code> <code>int</code> <p>indexes where to cut the BinaPy</p> <code>()</code> <p>Returns:</p> Type Description <code>List[BinaPy]</code> <p><code>len(pos) + 1</code> parts, instances of BinaPy</p> Source code in <code>binapy/binapy.py</code> <pre><code>def cut_at(self, *pos: int) -&gt; \"List[BinaPy]\":\n\"\"\"Cut this BinaPy at one or more integer positions.\n\n    Args:\n        *pos: indexes where to cut the BinaPy\n\n    Returns:\n        `len(pos) + 1` parts, instances of BinaPy\n    \"\"\"\n    spos = sorted(pos)\n    return [\n        self.__class__(self[start:end])\n        for start, end in zip([0] + spos, spos + [len(self)])\n    ]\n</code></pre>"},{"location":"api/#binapy.binapy.BinaPy.encode_to","title":"<code>encode_to(name, *args, **kwargs)</code>","text":"<p>Encode data from this BinaPy according to the format <code>name</code>.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>format to use</p> required <code>*args</code> <code>Any</code> <p>additional position parameters for the extension encoder method</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>additional keyword parameters for the extension encoder method</p> <code>{}</code> <p>Returns:</p> Type Description <code>BinaPy</code> <p>the resulting data</p> Source code in <code>binapy/binapy.py</code> <pre><code>def encode_to(self, name: str, *args: Any, **kwargs: Any) -&gt; \"BinaPy\":\n\"\"\"Encode data from this BinaPy according to the format `name`.\n\n    Args:\n        name: format to use\n        *args: additional position parameters for the extension encoder method\n        **kwargs: additional keyword parameters for the extension encoder method\n\n    Returns:\n        the resulting data\n    \"\"\"\n    encoder = self._get_encoder(name)\n\n    return encoder(self, *args, **kwargs)\n</code></pre>"},{"location":"api/#binapy.binapy.BinaPy.to","title":"<code>to(name, *args, **kwargs)</code>","text":"<p>Alias for <code>encode_to()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>same as <code>encode_to()</code></p> required <code>*args</code> <code>Any</code> <p>same as <code>encode_to()</code></p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>same as <code>encode_to()</code></p> <code>{}</code> <p>Returns:</p> Type Description <code>BinaPy</code> <p>same as <code>encode_to()</code></p> Source code in <code>binapy/binapy.py</code> <pre><code>def to(self, name: str, *args: Any, **kwargs: Any) -&gt; \"BinaPy\":  # noqa: D402\n\"\"\"Alias for `encode_to()`.\n\n    Args:\n        name: same as `encode_to()`\n        *args:  same as `encode_to()`\n        **kwargs:  same as `encode_to()`\n\n    Returns:\n        same as `encode_to()`\n    \"\"\"\n    return self.encode_to(name, *args, **kwargs)\n</code></pre>"},{"location":"api/#binapy.binapy.BinaPy.decode_from","title":"<code>decode_from(name, *args, **kwargs)</code>","text":"<p>Decode data from this BinaPy according to the format <code>name</code>.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>format name to use</p> required <code>*args</code> <code>Any</code> <p>additional position parameters for the extension decoder method</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>additional keyword parameters for the extension decoder method</p> <code>{}</code> <p>Returns:</p> Type Description <code>BinaPy</code> <p>the resulting data</p> Source code in <code>binapy/binapy.py</code> <pre><code>def decode_from(self, name: str, *args: Any, **kwargs: Any) -&gt; \"BinaPy\":\n\"\"\"Decode data from this BinaPy according to the format `name`.\n\n    Args:\n        name: format name to use\n        *args: additional position parameters for the extension decoder method\n        **kwargs: additional keyword parameters for the extension decoder method\n\n    Returns:\n        the resulting data\n    \"\"\"\n    decoder = self._get_decoder(name)\n\n    return decoder(self, *args, **kwargs)\n</code></pre>"},{"location":"api/#binapy.binapy.BinaPy.check","title":"<code>check(name, decode=False, raise_on_error=False)</code>","text":"<p>Check that this BinaPy conforms to a given format extension.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>the name of the extension to check</p> required <code>decode</code> <code>bool</code> <p>if <code>True</code>, and the given extension doesn't have a checker method, try to decode this BinaPy using the decoder method to check if that works.</p> <code>False</code> <code>raise_on_error</code> <code>bool</code> <p>if True, Exceptions from the checker method, if any, will be raised instead of returning <code>False</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>bool</code> <p>a boolean, that is True if this BinaPy conforms to the given extension format, False otherwise.</p> Source code in <code>binapy/binapy.py</code> <pre><code>def check(\n    self, name: str, decode: bool = False, raise_on_error: bool = False\n) -&gt; bool:\n\"\"\"Check that this BinaPy conforms to a given format extension.\n\n    Args:\n        name: the name of the extension to check\n        decode: if `True`, and the given extension doesn't have a checker method, try to decode this BinaPy using the decoder method to check if that works.\n        raise_on_error: if True, Exceptions from the checker method, if any, will be raised instead of returning `False`.\n\n    Returns:\n        a boolean, that is True if this BinaPy conforms to the given extension format, False otherwise.\n    \"\"\"\n    # raises an exception in case the extension doesn't exist\n    self._get_extension_methods(name)\n\n    try:\n        checker = self._get_checker(name)\n        try:\n            return checker(self)\n        except InvalidExtensionMethod as exc:\n            raise exc\n        except Exception as exc:\n            if raise_on_error:\n                raise exc from exc\n            return False\n    except NotImplementedError:\n        try:\n            # if checker is not implemented and decode is True, try to decode instead\n            if decode:\n                decoder = self._get_decoder(name)\n                try:\n                    decoder(self)\n                    return True\n                except Exception as exc:\n                    if raise_on_error:\n                        raise exc from exc\n                    return False\n        except NotImplementedError:\n            return False\n    return False\n</code></pre>"},{"location":"api/#binapy.binapy.BinaPy.check_all","title":"<code>check_all(decode=False)</code>","text":"<p>Check if this BinaPy conforms to any of the registered format extensions.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>a list of format extensions that this BinaPy can be decoded from.</p> <p>Parameters:</p> Name Type Description Default <code>decode</code> <code>bool</code> <p>if <code>True</code>, for extensions that don't have a checker method, try to decode this BinaPy using the decoder method to check if that works.</p> <code>False</code> Source code in <code>binapy/binapy.py</code> <pre><code>def check_all(self, decode: bool = False) -&gt; List[str]:\n\"\"\"Check if this BinaPy conforms to any of the registered format extensions.\n\n    Returns:\n         a list of format extensions that this BinaPy can be decoded from.\n\n    Args:\n        decode: if `True`, for extensions that don't have a checker method,\n            try to decode this BinaPy using the decoder method to check if that works.\n    \"\"\"\n\n    def get_results() -&gt; Iterator[str]:\n        for name in self.extensions:\n            success = self.check(name, decode=decode)\n            if success is True:\n                yield name\n\n    return list(get_results())\n</code></pre>"},{"location":"api/#binapy.binapy.BinaPy.parse_from","title":"<code>parse_from(name, *args, **kwargs)</code>","text":"<p>Parse data from this BinaPy, based on a given format extension.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of the extension to use</p> required <code>*args</code> <code>Any</code> <p>additional position parameters for the extension decoder method</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>additional keyword parameters for the extension decoder method</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>the result from parsing this BinaPy</p> Source code in <code>binapy/binapy.py</code> <pre><code>def parse_from(self, name: str, *args: Any, **kwargs: Any) -&gt; Any:\n\"\"\"Parse data from this BinaPy, based on a given format extension.\n\n    Args:\n        name: name of the extension to use\n        *args: additional position parameters for the extension decoder method\n        **kwargs: additional keyword parameters for the extension decoder method\n\n    Returns:\n        the result from parsing this BinaPy\n    \"\"\"\n    parser = self._get_parser(name)\n\n    return parser(self, *args, **kwargs)\n</code></pre>"},{"location":"api/#binapy.binapy.BinaPy.serialize_to","title":"<code>serialize_to(name, *args, **kwargs)</code>  <code>classmethod</code>","text":"<p>Serialize (dump) data to a BinaPy, based on a given extension format.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of the extension to use</p> required <code>*args</code> <code>Any</code> <p>additional position parameters for the extension decoder method (which includes the data to serialize)</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>additional keyword parameters for the extension decoder method</p> <code>{}</code> <p>Returns:</p> Type Description <code>BinaPy</code> <p>a BinaPy, resulting from serialization of the data</p> Source code in <code>binapy/binapy.py</code> <pre><code>@classmethod\ndef serialize_to(cls, name: str, *args: Any, **kwargs: Any) -&gt; \"BinaPy\":\n\"\"\"Serialize (dump) data to a BinaPy, based on a given extension format.\n\n    Args:\n        name: name of the extension to use\n        *args: additional position parameters for the extension decoder method (which includes the data to serialize)\n        **kwargs: additional keyword parameters for the extension decoder method\n\n    Returns:\n        a BinaPy, resulting from serialization of the data\n    \"\"\"\n    serializer = cls._get_serializer(name)\n\n    return serializer(*args, **kwargs)\n</code></pre>"},{"location":"api/#binapy.binapy.BinaPy.register_extension","title":"<code>register_extension(name, feature, func)</code>  <code>classmethod</code>","text":"<p>Register a new feature for the given extension name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>the extension name</p> required <code>feature</code> <code>str</code> <p>name of the feature to register (\"encode\", \"decode\", etc.)</p> required <code>func</code> <code>Callable[..., Any]</code> <p>the method implementing the feature</p> required Source code in <code>binapy/binapy.py</code> <pre><code>@classmethod\ndef register_extension(\n    cls, name: str, feature: str, func: Callable[..., Any]\n) -&gt; None:\n\"\"\"Register a new feature for the given extension name.\n\n    Args:\n        name: the extension name\n        feature: name of the feature to register (\"encode\", \"decode\", etc.)\n        func: the method implementing the feature\n    \"\"\"\n    ext_dict = cls.extensions.setdefault(name, {})\n    ext_dict[feature] = func\n</code></pre>"},{"location":"api/#binapy.InvalidExtensionMethod","title":"<code>InvalidExtensionMethod</code>","text":"<p>         Bases: <code>ValueError</code></p> <p>Raised when an extension method returns invalid data.</p> Source code in <code>binapy/binapy.py</code> <pre><code>class InvalidExtensionMethod(ValueError):\n\"\"\"Raised when an extension method returns invalid data.\"\"\"\n</code></pre>"},{"location":"authors/","title":"authors","text":""},{"location":"authors/#credits","title":"Credits","text":""},{"location":"authors/#development-lead","title":"Development Lead","text":"<ul> <li>Guillaume Pujol guill.p.linux@gmail.com</li> </ul>"},{"location":"authors/#contributors","title":"Contributors","text":"<p>None yet. Why not be the first?</p>"},{"location":"contributing/","title":"contributing","text":""},{"location":"contributing/#contributing","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p> <p>You can contribute in many ways:</p>"},{"location":"contributing/#types-of-contributions","title":"Types of Contributions","text":""},{"location":"contributing/#report-bugs","title":"Report Bugs","text":"<p>Report bugs at https://github.com/guillp/binapy/issues.</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Your operating system name and version.</li> <li>Any details about your local setup that might be helpful in troubleshooting.</li> <li>Detailed steps to reproduce the bug.</li> </ul>"},{"location":"contributing/#fix-bugs","title":"Fix Bugs","text":"<p>Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it.</p>"},{"location":"contributing/#implement-features","title":"Implement Features","text":"<p>Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it.</p>"},{"location":"contributing/#write-documentation","title":"Write Documentation","text":"<p>BinaPy could always use more documentation, whether as part of the official BinaPy docs, in docstrings, or even on the web in blog posts, articles, and such.</p>"},{"location":"contributing/#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/guillp/binapy/issues.</p> <p>If you are proposing a feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project, and that contributions   are welcome :)</li> </ul>"},{"location":"contributing/#get-started","title":"Get Started!","text":"<p>Ready to contribute? Here's how to set up <code>binapy</code> for local development.</p> <ol> <li>Fork the <code>binapy</code> repo on GitHub.</li> <li>Clone your fork locally</li> </ol> <pre><code>    $ git clone git@github.com:your_name_here/binapy.git\n</code></pre> <ol> <li>Ensure poetry is installed.</li> <li>Install dependencies and start your virtualenv:</li> </ol> <pre><code>    $ poetry install -E test -E doc -E dev\n</code></pre> <ol> <li>Create a branch for local development:</li> </ol> <pre><code>    $ git checkout -b name-of-your-bugfix-or-feature\n</code></pre> <p>Now you can make your changes locally.</p> <ol> <li>When you're done making changes, check that your changes pass the    tests, including testing other Python versions, with tox:</li> </ol> <pre><code>    $ tox\n</code></pre> <ol> <li>Commit your changes and push your branch to GitHub:</li> </ol> <pre><code>    $ git add .\n    $ git commit -m \"Your detailed description of your changes.\"\n    $ git push origin name-of-your-bugfix-or-feature\n</code></pre> <ol> <li>Submit a pull request through the GitHub website.</li> </ol>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <ol> <li>The pull request should include tests.</li> <li>If the pull request adds functionality, the docs should be updated. Put    your new functionality into a function with a docstring, and add the    feature to the list in README.md.</li> <li>The pull request should work for Python 3.6, 3.7, 3.8, 3.9 and for PyPy. Check    https://github.com/guillp/binapy/actions    and make sure that the tests pass for all supported Python versions.</li> </ol>"},{"location":"contributing/#tips","title":"Tips","text":"<p>To run a subset of tests, here only those from <code>test_binapy</code>:</p> <pre><code>    $ pytest tests.test_binapy\n</code></pre>"},{"location":"contributing/#deploying","title":"Deploying","text":"<p>A reminder for the maintainers on how to deploy. Make sure all your changes are committed (including an entry in HISTORY.md). Then run:</p> <pre><code>$ poetry patch # possible: major / minor / patch\n$ git push\n$ git push --tags\n</code></pre> <p>Travis will then deploy to PyPI if tests pass.</p>"},{"location":"history/","title":"history","text":""},{"location":"history/#history","title":"History","text":""},{"location":"history/#030-2021-11-15","title":"0.3.0 (2021-11-15)","text":"<ul> <li>Renaming <code>serialize_from()</code> to <code>serialize_to()</code> and <code>parse_to()</code> to <code>parse_from()</code>.</li> </ul>"},{"location":"history/#020-2021-11-10","title":"0.2.0 (2021-11-10)","text":"<ul> <li>Serialize JSON as compact by default</li> <li><code>datetime</code> instances are serialized to epoch timestamps when serializing JSON (but they are not converted back on parsing).</li> <li>add <code>.to_int()</code> to convert a BinaPy to an int.</li> </ul>"},{"location":"history/#010-2021-07-08","title":"0.1.0 (2021-07-08)","text":"<ul> <li>First release on PyPI.</li> </ul>"},{"location":"installation/","title":"installation","text":""},{"location":"installation/#installation","title":"Installation","text":""},{"location":"installation/#stable-release","title":"Stable release","text":"<p>To install BinaPy, run this command in your terminal:</p> <pre><code>$ pip install binapy\n</code></pre> <p>This is the preferred method to install BinaPy, as it will always install the most recent stable release.</p> <p>If you don't have pip installed, this Python installation guide can guide you through the process.</p>"},{"location":"installation/#from-source","title":"From source","text":"<p>The source for BinaPy can be downloaded from the Github repo.</p> <p>You can either clone the public repository:</p> <pre><code>$ git clone git://github.com/guillp/binapy\n</code></pre> <p>Or download the tarball:</p> <pre><code>$ curl -OJL https://github.com/guillp/binapy/tarball/master\n</code></pre> <p>Once you have a copy of the source, you can install it with:</p> <pre><code>$ pip install .\n</code></pre>"},{"location":"usage/","title":"usage","text":""},{"location":"usage/#usage","title":"Usage","text":""},{"location":"usage/#import","title":"Import","text":"<p>To use BinaPy in a project, import the main class like this:</p> <pre><code>from binapy import BinaPy\n</code></pre> <p><code>BinaPy</code> is a subclass of Python's built-in <code>bytes</code>, so you can use it anywhere a <code>bytes</code> is required. You may also <code>.decode()</code> it to convert it to a <code>str</code>, or use any of the default methods from <code>bytes</code> It also provides a few additional convenience methods, such as <code>cut_at(*pos)</code>, <code>.ascii()</code>, etc.</p>"},{"location":"usage/#initialize","title":"Initialize","text":"<p>To initialize a <code>BinaPy</code>:</p> <ul> <li>from a <code>bytes</code>: <code>bp = BinaPy(b'my raw bytes \\x01\\xcf'</code>)</li> <li>from a <code>str</code>: <code>bp = BinaPy(\"my string\", encoding='cp1252')</code>. If <code>encoding</code> is omitted, it will default to <code>'utf-8'</code>. That is a different to the <code>bytes</code> constructor where encoding is mandatory when you give it a <code>str</code> as value.</li> <li>from a <code>bytearray</code>: <code>bp = BinaPy(bytearray(b'my bytearray data'))</code></li> <li>from an <code>int</code> array: bp = <code>BinaPy([109, 121, 32, 105, 110, 116, 32, 97, 114, 114, 97, 121])</code></li> <li>from an <code>int</code>: <code>bp = BinaPy.from_int(82412341)</code>. You may additionally pass <code>size</code>, <code>order</code>, and <code>signed</code> parameters, with the same semantics as <code>int.to_bytes((length, byteorder, signed=False)</code>. You can do the opposite and convert an BinaPy to an int with <code>bp.to_int()</code>.</li> <li>with random data, of arbitrary size: <code>bp = BinaPy.random(32)</code>. The parameter is the size of the generated data, in bytes.</li> <li>from a string containing the binary representation of your data: <code>bp = BinaPy.from_binary_string('101010')</code>. The reverse transformation is available with <code>bp.to_binary_string()</code>.</li> </ul>"},{"location":"usage/#encoding--decoding--transformations","title":"Encoding / Decoding / Transformations","text":"<p>Use the methods <code>encode_to()</code> (or its alias <code>.to()</code>) and <code>decode_from()</code> to transform a BinaPy value into another, using an encoding or transformation scheme. The result value being a BinaPy, you can keep applying those transformations fluently.</p> <p>For example, to generate a random binary data, hash it with SHA256 then Base64-url encode the result:</p> <pre><code>bp = BinaPy.random(128).to(\"sha256\").encode_to(\"b64u\")\nprint(bp)\n# b'QTs64tuMZ-TnyYPhjopIryaFPeF26SKKN4y-su2sBYg'\n</code></pre> <p>To illustrate the <code>.decode_from()</code> method, lets Base64-url decode this value and convert it to hex:</p> <pre><code>print(bp.decode_from(\"b64u\").to(\"hex\"))\n# b'413b3ae2db8c67e4e7c983e18e8a48af26853de176e9228a378cbeb2edac0588'\n</code></pre> <p>A few noteworthy remarks:</p> <ul> <li>some transformations, such as hashes, are irreversible, so they can only be used with the <code>encode_to()</code> method.</li> <li>the verb encode is not really suitable for hashes. That's one of the 2 reasons the <code>.to()</code> alias exists. The other reason is that it's shorter :)</li> <li>there is no <code>from()</code> alias to <code>decode_from()</code>. That's because <code>from</code> is a reversed word in Python, so it cannot be used as a method name. <code>from_()</code> could be used but it makes the code much uglier than <code>decode_from()</code>.</li> </ul>"},{"location":"usage/#converting-from-binary-to-text-or-numeric-data-types","title":"Converting from binary to text or numeric data types","text":"<p><code>BinaPy</code> has a few convenience methods to convert a binary data into:</p> <ul> <li>a string: you can use <code>.decode()</code> as usual, with any Python-supported encoding as parameter. However, very often you will want to have a limited set of characters in the result. You can check this by using <code>.ascii()</code>, <code>.text()</code>, <code>.urlsafe()</code>, <code>.alphanumeric()</code></li> <li>an integer: use <code>.to_int()</code>, with optional parameters <code>byteorder</code> and <code>signed</code> with the same semantics as int.from_bytes.</li> <li>a binary string: use <code>.to_binary_string()</code>.</li> </ul>"},{"location":"usage/#checking-data-contents","title":"Checking data contents","text":"<p>You can check if a BinaPy data conforms with a given extension using the <code>.check(name)</code> method.</p> <pre><code>bp = BinaPy(b\"ThisIsData==\")\nbp.check(\"b64\")\n# True\nbp.check(\"hex\")\n# False\n</code></pre> <p>You can also check a BinaPy against all extensions using <code>.check_all()</code>. For example, any random 20 bytes could be the result from a SHA1 hash:</p> <pre><code>bp = BinaPy.random(20)\nbp.check_all()\n# ['sha1']\n</code></pre> <p>While a given string with only hex characters could be a hexadecimal string, it could also be the result of a base64 or a base64url encoding.</p> <pre><code>bp = BinaPy(\"abcdef1234567890\")\nbp.check_all()\n# ['b64', 'b64u', 'hex']\n# ['b64', 'b64u', 'hex']\n</code></pre>"},{"location":"usage/#loading-and-dumping","title":"Loading and dumping","text":"<p>Dumping and encoding data can be done this way:</p> <pre><code>BinaPy.serialize_to(\"json\", {\"foo\": \"bar\"}).to(\"b64u\")\n# b'ewoiZm9vIjogImJhciIKfQ'\n</code></pre> <p>Loading serialized and encoded data can be done this way:</p> <pre><code>BinaPy(b\"ewoiZm9vIjogImJhciIKfQ\").decode_from(\"b64u\").parse_from(\"json\")\n# {'foo': 'bar'}\n</code></pre>"},{"location":"usage/#extend","title":"extend","text":"<p>You can implement additional methods for BinaPy. Methods can implement one or several of the following features:</p> <ul> <li>an encoder: this will transform/encode the current BinaPy into another BinaPy. E.g., a base64 encoder will transform arbitrary binary data into a base64 encoded string.</li> <li>a decoder: this will transform an encoded data back into its initial data. E.g., a base64 decoder.</li> <li>a checker: this will check if a given data conforms to a given format. Which means that this data could have been produced with a matching encoder and can probably be decoded with the matching decoder, if available.</li> <li>a parser: this will parse the current BinaPy data into another format. E.g., a JSON parser</li> <li>a serializer: this will serialize data from another format into a BinaPy. E.g, a JSON dumper</li> </ul> <p>Note that the terms encode and decode are quite loose, because they are applied to compression, hashing and other transformations that produce or consume binary data.</p> <p>To implement such a method, use one of the <code>binapy_&lt;feature&gt;()</code> decorators. Each decorator takes the name of the extension as parameter.</p> <pre><code>from binapy import binapy_encoder\n\n\n@binapy_encoder(\"myformat\")\ndef encode_myformat(bp) -&gt; bytes:\n    # apply your transformation\n    return my_transformation(bp)\n</code></pre> <p>This <code>binapy_encoder()</code> decorator will:</p> <ul> <li>register this method in BinaPy extension registry, so that it can be called with <code>BinaPy(my_data).encode_to('myformat')</code>.</li> <li>if that methods returns a <code>bytes</code> or a <code>bytesarray</code>, make sure that it returns a <code>BinaPy</code> instead, to make sure it is fluent.</li> </ul> <p>Some formats such as base64 can have all 3 methods implemented. Others such as hashes only have an encoder and a checker method:</p> <ul> <li>the encoder does the actual hashing (that is, by definition, irreversible)</li> <li>the checker method checks that a given data is the appropriate length for the given hash</li> </ul> <p>Finally, some formats like gzip do not have a checker method, because trying to decode the data is faster and easier than validating it statically. BinaPy will then try the decode method instead and see if it raises an Exception.</p>"}]}